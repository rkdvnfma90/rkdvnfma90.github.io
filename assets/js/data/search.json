[ { "title": "RTK Cheat Sheet", "url": "/posts/RTK-cheat-sheet/", "categories": "RTK", "tags": "RTK", "date": "2022-03-19 11:56:00 +0900", "snippet": "RTK (Redux Toolkit)Redux Toolkit (이하 RTK)은 Redux 개발을 효율적으로 할수있게 하는 공식 개발도구이다.기존 Redux는 많은 보일러 플레이트 코드가 필요했고, 조금 더 유용하게 사용하기 위해 더 많은 패키지들을 추가로 설치해야 했다. 이런 불편한 점을 해소하기 위해 RTK가 나왔다고 할 수 있겠다!설치RTK는 빌트인 타입스크립트이기 때문에 별도의 타입설치가 필요하지 않다.yarn add @reduxjs/toolkit react-redux혹은npx create-react-app my-app --template redux-typescriptRTK가 포함하고 있는 API configureStore(): 더 간단한 설정 옵션과 기본값들을 제공하기 위해 기존 Redux의 createStore를 래핑한 API 이다. 자동으로 슬라이스와 리듀서들을 결합하고 미들웨어를 추가할 수 있다. redux-thunk를 포함하고 있다. 기본적으로 Redux DevTools Extension을 사용할 수 있다. import { configureStore } from &#39;@reduxjs/toolkit&#39;import rootReducer from &#39;./reducers&#39;const store = configureStore({ reducer: rootReducer })// The store now has redux-thunk added and the Redux DevTools Extension is turned on createReducer(): 리듀서 함수를 switch 구문을 사용하지 않고 작성할 수 있다. 또한 자동으로 immer 라이브러리를 사용하여 state.todos[3].completed = true와 같이 직접 상태를 변경하는 것처럼 사용할 수 있다. import { createAction, createReducer } from &#39;@reduxjs/toolkit&#39;interface CounterState { value: number}const increment = createAction(&#39;counter/increment&#39;)const decrement = createAction(&#39;counter/decrement&#39;)const incrementByAmount = createAction&amp;lt;number&amp;gt;(&#39;counter/incrementByAmount&#39;)const initialState = { value: 0 } as CounterStateconst counterReducer = createReducer(initialState, (builder) =&amp;gt; { builder .addCase(increment, (state, action) =&amp;gt; { state.value++ }) .addCase(decrement, (state, action) =&amp;gt; { state.value-- }) .addCase(incrementByAmount, (state, action) =&amp;gt; { state.value += action.payload })})// 이렇게도 사용할 수 있다.const increment = createAction(&#39;increment&#39;)const decrement = createAction(&#39;decrement&#39;)const counterReducer = createReducer(0, { [increment]: (state, action) =&amp;gt; state + action.payload, [decrement.type]: (state, action) =&amp;gt; state - action.payload}) createAction(): 주어진 문자열에 대한 액션 생성자 함수를 생성한다. 이 함수 자체에는 toString()이 정의되어 있기 때문에 constant 타입 대신에 사용이 가능하다. const INCREMENT = &#39;counter/increment&#39;function increment(amount: number) { return { type: INCREMENT, payload: amount, }}let action = increment()// { type: &#39;counter/increment&#39; }action = increment(3)// { type: &#39;counter/increment&#39;, payload: 3 }console.log(increment.toString())// &#39;counter/increment&#39;console.log(`The action type is: ${increment}`)// &#39;The action type is: counter/increment&#39; createSlice(): 리듀서 함수, 슬라이스 이름, 기본값을 넣을 수 있고 액션 생성자와 액션 타입을 가진 슬라이스 리듀서를 생성한다. import { createSlice, PayloadAction } from &#39;@reduxjs/toolkit&#39;interface CounterState { value: number}const initialState = { value: 0 } as CounterStateconst counterSlice = createSlice({ name: &#39;counter&#39;, initialState, reducers: { increment(state) { state.value++ }, decrement(state) { state.value-- }, incrementByAmount(state, action: PayloadAction&amp;lt;number&amp;gt;) { state.value += action.payload }, },})export const { increment, decrement, incrementByAmount } = counterSlice.actionsexport default counterSlice.reducer createAsyncThunk: 프로미스를 리턴하는 액션 타입 문자열과 함수를 허용하고, 이 프로미스를 기반으로 하는 pending/fulfilled/rejected thunk를 생성한다. import { createAsyncThunk, createSlice } from &#39;@reduxjs/toolkit&#39;import { userAPI } from &#39;./userAPI&#39;// First, create the thunkconst fetchUserById = createAsyncThunk( &#39;users/fetchByIdStatus&#39;, async (userId, thunkAPI) =&amp;gt; { const response = await userAPI.fetchById(userId) return response.data })// Then, handle actions in your reducers:const usersSlice = createSlice({ name: &#39;users&#39;, initialState: { entities: [], loading: &#39;idle&#39; }, reducers: { // standard reducer logic, with auto-generated action types per reducer }, extraReducers: (builder) =&amp;gt; { // Add reducers for additional action types here, and handle loading state as needed builder.addCase(fetchUserById.fulfilled, (state, action) =&amp;gt; { // Add user to the state array state.entities.push(action.payload) }) },})// Later, dispatch the thunk as needed in the appdispatch(fetchUserById(123)) createEntityAdapter: 스토어에서 정규화된 데이터를 관리하기 위해 재사용 가능한 리듀서, selector의 집합을 생성한다. createSelector: reselect 라이브러리의 createSelector.createAction액션 생성자 함수 생성const increment = createAction(&quot;counter/increment&quot;);const action = increment(10); // { type: &quot;counter/increment&quot;, payload: 10 }createAction은 타입 문자열만 제공하면 바로사용할 수 있고, 생성된 액션 생성자의 파라미터로 값을 넘기면 그 값은 payload 필드에 들어간다.리턴될 payload 객체를 커스터마이징 하고 싶다면 createAction 함수의 두 번째 인자로 콜백 함수를 넘기면 된다.const addTodo = createAction(&quot;todo/add&quot;, (text) =&amp;gt; { return { payload: { text, uuid: generateUUID(); } }});addTodo(&quot;제주도 여행&quot;);/*해당 객체 리턴{ type: &quot;todo/add&quot;, payload: { text: &quot;제주도 여행&quot;, uuid: &quot;AOF438ASDFXVBC32&quot;, }}*/콜백함수 안에서는 액션 생성자 함수의 파라미터로 전달받지 않은 데이터들을 추가할 수 있고 이 때 객체의 형태는 반드시 FSA(Flux Standard Action) 형태를 따라야 한다.createReducer리듀서 생성const increment = createAction(&quot;increment&quot;);const decrement = createAction(&quot;decrement&quot;);const counterReducer = createReducer(0, { [increment]: (state, action) =&amp;gt; state + action.payload, [decrement.type]: (state, action) =&amp;gt; state - action.payload});createReducer의 두 번째 파라미터인 리듀서 맵에는 액션 생성자에 전달한 문자열을 그대로 넣어도 되지만 (“increment”) 액션 생성자 함수 그 자체를 넣어도 된다. 그 이유는 createAction이 리턴하는 액션 생성자 함수의 toString을 오버라이딩 했기 때문createSlice액션과 리듀서를 한번에 생성const todoSlice = createSlice({ name: &quot;todo&quot;, // 액션 타입 문자열의 prefix initialState: [], // 초기값 reducers: { // 리듀서 맵 addTodo: { // 리듀서 함수 reducer: (state, action) =&amp;gt; { state.push(action.payload); }, // createAction 함수의 두 번째 파라미터의 콜백 함수라고 보면 된다. prepare: (text: string) =&amp;gt; ({ payload: { id: generateUUID(), text } }) }, // 리듀서와 액션 생성 함수를 분리하지 않고 사용할 수 있다. removeTodo: (state, action) =&amp;gt; { state.splice( state.findIndex(item =&amp;gt; item.id === action.payload.id), 1 ); } }});// 액션과 리듀서를 아래와 같이 가져올 수 있다.const { addTodo, removeTodo } = todoSlice.actions;const { reducer } = todoSlice;createSelector리덕스 스토어에서 state 값을 조회하기 위해 사용한다.여기서 selector란 의미는 Redux에서 어떤 state를 기반으로 새로운 state를 리턴하는 함수를 말한다. 예를 들어 Todo 리스트에서 완료된 것 만 필터링할 때 보통 사용하곤 한다.RTK의 createSelector는 reselect 라이브러리의 createSelector와 같다. (메모이제이션 지원)화해 블로그 참조const shopItemsSelector = state =&amp;gt; state.shop.items;const taxPercentSelector = state =&amp;gt; state.shop.taxPercent;// subtotal 값을 메모이제이션const subtotalSelector = createSelector( shopItemsSelector, items =&amp;gt; items.reduce((subtotal, item) =&amp;gt; subtotal + item.value, 0));const totalSelector = createSelector( subtotalSelector, taxSelector, (subtotal, tax) =&amp;gt; ({ total: subtotal + tax }));createSelector를 호출할 때 파라미터의 개수제한은 없지만 가장 마지막 파라미터는 상태 객체를 리턴할 콜백 함수가 들어가야 한다. 이 콜백 함수의 파라미터는 앞에 있는 파라미터에서 리턴한 객체가 차례대로 위치한다." }, { "title": "Git Cheat Sheet", "url": "/posts/git-cheat-sheet/", "categories": "TIL", "tags": "Git", "date": "2022-03-11 15:33:00 +0900", "snippet": "Branch git checkout [해시코드, 브랜치] : HEAD를 명시한 브랜치, 해시코드로 옮긴다. (브랜치 이동같은 경우 git switch 명령어를 사용해도 된다) git branch --merged : 현재 브랜치에 merge된 브랜치들을 확인할 수 있다. git branch --no-merged : 현재 브랜치에 merge가 되지 않은 브랜치들을 확인할 수 있다. git push origin --delete [삭제할 브랜치명] : 로컬에서 삭제한 브랜치를 원격에 반영한다. git branch --move [A] [B] : A브랜치의 이름을 B로 변경한다. git branch --set-upstream origin [B] : 변경한 브랜치를 원격에 반영한다. git log [A]..[B] : A와 B브랜치 사이에 있는 커밋들만 확인 가능. git diff [A]..[B] : A와 B브랜치 사이에 있는 코드 변경사항들만 확인 가능.&amp;lt;/br&amp;gt;&amp;lt;/br&amp;gt;Merge fast-forward merge 가장 깔끔하고 간단하다. 마스터 브랜치에서 새로운 브랜치(feature A)가 생성된 이후에 마스터 브랜치에 변동사항이 없다면 merge를 할 때 단순히 마스터 브랜치가 가리키고 있는 포인터를 옮기는 것이다. (d -&amp;gt; f) 그 후 feature A 브랜치를 삭제하면 끝! 단점으로는 히스토리에 merge가 되었다는 내용이 남지 않는다. 그래서 히스토리를 남기고자 한다면 별도의 merge commit을 만든다. 이것을 three-way merge라고 한다. three-way merge merge할 때 히스토리를 남기기 위한 방법이다. git merge --no-ff [merge할 브랜치명] : 이 명령어를 통해 three-way merge를 할 수 있다. 해당 명령어 수행 후 커밋메시지 입력! 충돌 발생시 해결 후 git add [충돌해결 한 파일] -&amp;gt; git merge --continue로 merge 진행 (단, fast-forward merge가 아니기 때문에 merge 커밋이 만들어진다.), 만약 merge를 취소하고 싶으면 git merge --abort 충돌해결 vscode로 진행하기 : git config --global -e 명령어로 설정파일을 열고 다음과 같이 추가해준다. [merge] tool = vscode[mergetool &quot;vscode&quot;] cmd = code --wait $MERGED 충돌 발생 후 git mergetool명령어를 사용하여 vscode에서 충돌을 해결할 수 있다. 충돌 해결 후 아래와 같이 해당 파일의 .orig 확장자의 파일이 나올 수 있는데 이 파일은 충돌이 발생했을 때의 내용을 담고있는 파일이다.이것을 끄기위해 git config --global mergetool.keepBackup false 명령어를 실행시켜주자rebase three-way merge 상황일 경우 히스토리에 merge 커밋이 남게 된다. 별도의 merge commit이 생기지 않게 하는 방법이 바로 rebase이다. 위 사진과 같이 three-way merge 상황일 때 feature A브랜치를 master브랜치 최신 버전으로 rebase를 한다면 아래와 같이 fast-forward merge가 가능해진다. 주의할 점은 feature A브랜치에서 나 혼자만 작업하고 있다면 상관없지만 다른 개발자와 함께 feature A브랜치에서 작업을 하고 있다면 위험할 수가 있다. 그 이유는 rebase를 하게 되면 해당 커밋의 포인터를 변경하게 되는데 포인터의 정보를 변경하게 되면 기존의 커밋을 유지하는 것이 아니라 새로운 커밋을 만들게 된다. (겉으로는 똑같아 보이지만 실제로는 다르다) 그렇기 때문에 이미 히스토리가 원격지에 업로드 되어 있다면 업로드된 히스토리는 절대 rebase 하지말자! (내 로컬에 있는 커밋에는 rebase를 자유롭게 해도 된다!)" }, { "title": "2022-02-17 TIL", "url": "/posts/TIL/", "categories": "TIL", "tags": "Typescript", "date": "2022-02-17 15:15:00 +0900", "snippet": "Pickimport { FormikHandlers } from &quot;formik&quot;;interface Values { [key: string]: string;}interface Props { handleChange: Pick&amp;lt;FormikHandlers, &quot;handleChange&quot;&amp;gt;; handleSubmit: Pick&amp;lt;FormikHandlers, &quot;handleSubmit&quot;&amp;gt;; handleBlur: Pick&amp;lt;FormikHandlers, &quot;handleBlur&quot;&amp;gt;; values: Values;}const CommonSearchForm = ({ handleChange, handleSubmit, handleBlur, values,}: Props) =&amp;gt; { console.log(handleChange); console.log(handleSubmit); console.log(handleBlur); console.log(values); return &amp;lt;div&amp;gt;CommonSearchForm&amp;lt;/div&amp;gt;;};export default CommonSearchForm;처음에 위 코드와 같이 formik의 FormikHandlers에서 해당 타입을 Pick을 사용하여 handleChange, handleSubmit 들의 타입을 가져오려고 했으나 사용하는 부분에서 아래와 같은 에러가 발생했다.&#39;handleChange&#39; 속성이 &#39;{ (e: ChangeEvent&amp;lt;any&amp;gt;): void; &amp;lt;T_1 = string | ChangeEvent&amp;lt;any&amp;gt;&amp;gt;(field: T_1): T_1 extends ChangeEvent&amp;lt;any&amp;gt; ? void : (e: string | ChangeEvent&amp;lt;any&amp;gt;) =&amp;gt; void; }&#39; 형식에 없지만 &#39;Pick&amp;lt;FormikHandlers, &quot;handleChange&quot;&amp;gt;&#39; 형식에서 필수입니다.ts(2741)types.d.ts(102, 5): 여기서는 &#39;handleChange&#39;이(가) 선언됩니다.그 이유는 Pick&amp;lt;Type, Key&amp;gt;은 주어진 Type에서 Key로 속성을 선택한 새로운 타입을 반환하기 때문이다. (내가 생각을 완전 잘못했음)해결첫 번째 방법import { FormikHandlers } from &quot;formik&quot;;interface Props { handleChange: FormikHandlers[&quot;handleChange&quot;]; handleSubmit: FormikHandlers[&quot;handleSubmit&quot;]; handleBlur: FormikHandlers[&quot;handleBlur&quot;]; values: Values;}const CommonSearchForm = ({ handleChange, handleSubmit, handleBlur, values,}: Props) =&amp;gt; { ... return &amp;lt;div&amp;gt;...&amp;lt;/div&amp;gt;};두 번째 방법import { FormikHandlers } from &quot;formik&quot;;interface Values { [key: string]: string;}const CommonSearchForm = ({ handleChange, handleSubmit, handleBlur, values,}: Pick&amp;lt;FormikHandlers, &quot;handleChange&quot; | &quot;handleSubmit&quot; | &quot;handleBlur&quot;&amp;gt; &amp;amp; { values: Values;}) =&amp;gt; { console.log(handleChange); console.log(handleSubmit); console.log(handleBlur); console.log(values); return &amp;lt;div&amp;gt;CommonSearchForm&amp;lt;/div&amp;gt;;};MappedType기존에 정의되어 있던 타입을 자바스크립트의 map() API 함수처럼 새로운 타입으로 정의해주는 것이다.type Subset&amp;lt;T&amp;gt; = { [key in keyof T]?: T[key];};type Subset&amp;lt;T&amp;gt; = { [key in keyof T]?: T[key];};interface Person { age: number; name: string;}const nameOnly: Subset&amp;lt;Person&amp;gt; = { name: &#39;Tony&#39; };" }, { "title": "2022-02-14 TIL", "url": "/posts/TIL/", "categories": "TIL", "tags": "Javascript", "date": "2022-02-14 16:40:00 +0900", "snippet": "클로저 활용if문 줄이기const log = (value) =&amp;gt; { return (fn) =&amp;gt; { fn(value); }};const customLog = log(&#39;Hi :)&#39;);customLog((message) =&amp;gt; console.log(message));customLog((message) =&amp;gt; console.info(message));customLog((message) =&amp;gt; console.error(message));customLog((message) =&amp;gt; console.warn(message));클로저를 사용하지 않았다면 if나 switch를 사용해야 했을 것이다.filter 리팩토링const arr = [1, 2, 3, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;];const isNumber = (value) =&amp;gt; typeof value === &#39;number&#39;;const isString = (value) =&amp;gt; typeof value === &#39;string&#39;;arr.filter(isNumber);arr.filter(isString);그렇다면 위 코드는 어떻게 클로저를 활용할 수 있을까?먼저 중복되는 부분을 찾아본다. typeof value === 부분이 중복된다.const isTypeOf = (type) =&amp;gt; (value) =&amp;gt; typeof value === type;const isNumber = isTypeOf(&#39;number&#39;);const isString = isTypeOf(&#39;string&#39;);arr.filter(isNumber);arr.filter(isString);커스텀 fetcherconst fetcher = endpoint =&amp;gt; { return (url, options) =&amp;gt; { return fetch(endpoint + url, options) .then(res =&amp;gt; { if (res.ok) { return res.json(); } else { throw new Error(res.error); } }) .catch(err =&amp;gt; console.error(err)); };};const naverApi = fetcher(&#39;https://www.naver.com/&#39;);const daumApi = fetcher(&#39;https://www.daum.net/&#39;);naverApi.fetch(&#39;/product&#39;).then((res) =&amp;gt; res);daumApi.fetch(&#39;/product&#39;).then((res) =&amp;gt; res);이런식으로 endpoint별 fetcher를 만들어서 재사용할 수 있다." }, { "title": "2022-02-10 TIL", "url": "/posts/TIL/", "categories": "TIL", "tags": "Javascript", "date": "2022-02-10 11:48:00 +0900", "snippet": "class에서의 화살표 함수class Parent { parentMethod() { console.log(&#39;parentMethod&#39;); } parentArrowMethod = () =&amp;gt; { console.log(&#39;parentArrowMethod&#39;); } overrideMethod = () =&amp;gt; { return &#39;Parent&#39;; }}class Child extends Parent { childMethod() { super.parentMethod(); } childArrowMethod() { super.parentArrowMethod(); } overrideMethod() { return &#39;Child&#39;; }}new Child().childMethod(); // parentMethodnew Child().childArrowMethod(); // Uncaught TypeError: (intermediate value).parentArrowMethod is not a function// Child가 리턴될것이라 예상했지만 Parent가 리텅되었다.// 이 부분을 예상하는 대로 나오게 하려면 Parent의 overrideMethod를 일반 메소드 형태로 작성하면 된다.new Child().overrideMethod(); 정리 클래스 메소드는 프로토타입에 정의되어 있기 때문에 상속 받은 곳에서 참조할 수 있지만 화살표 함수는 그렇지 못하다. 화살표 함수는 클래스 내부에서 선언했을 경우 생성자 함수 내부에서 바로 초기화 된다.addEventListener의 구조흔하게 사용하는 addEventListener의 콜백함수는 내부적으로 아래와 같이 동작할 것이라고 추측할 수 있다.someElement.addEventListener(&#39;click&#39;, (e) =&amp;gt; { console.log(&#39;someElement clicked!&#39;);});DOM.prototype.addEventListener = function(eventType, callbackFunc) { if (eventType === &#39;click&#39;) { // const clickEventObject = { target: {}, ... 등등등 } callbackFunc(clickEventObject); }}콜백함수를 활용한 리팩토링Beforefunction register() { const isConfirm = confirm(&#39;회원가입 성공&#39;) if (isConfirm) { redirectUserPage(); }}function login() { const isConfirm = confirm(&#39;로그인 성공&#39;) if (isConfirm) { redirectMainPage(); }}Afterfunction confirmModal(message, callbackFunc) { const isConfirm = confirm(message); if (isConfirm &amp;amp;&amp;amp; callbackFunc) { callbackFunc(); }}function register() { confirmModal(&#39;회원가입 성공&#39;, redirectUserPage);}function login() { confirmModal(&#39;로그인 성공&#39;, redirectMainPage);}콜백함수를 사용하여 제어권을 위임할 수 있다. (선언형)" }, { "title": "2022-02-06 TIL", "url": "/posts/TIL/", "categories": "TIL", "tags": "Javascript", "date": "2022-02-06 13:43:00 +0900", "snippet": "구조분해할당 활용배열의 구조분해 문법은 리액트에서 당연하게 사용한다.const [isLoading, setIsLoading] = useState(false);아래와 같은 방법도 많이 봤을 것이다.const orders = [&#39;First&#39;, &#39;Second&#39;, &#39;Third&#39;];const [first, , thrid] = orders;console.log(first); // Firstconsole.log(thrid); // Third하지만 요소가 많아진다면 이렇게 가독성이 좋아지지 않을 것이다.const [first, , , , , , some] = orders;이 때 조금 더 가독성 있게 사용하는 방법은 아래와 같다.const orders = [&#39;First&#39;, &#39;Second&#39;, &#39;Third&#39;];const { 0: first, 2: third } = orders;console.log(first); // Firstconsole.log(thrid); // Third많은 요소를 가지고 있는 배열을 분해할 때는 이 방법이 개인적으로 깔끔해 보인다 😎hasOwnProperty 주의사항hasOwnProperty는 해당 객체의 속성이 있는지 여부를 확인할 수 있는 메서드이다.const person = { name: &#39;aB&#39;}person.hasOwnProperty(&#39;name&#39;); // trueperson.hasOwnProperty(&#39;age&#39;); // false하지만 vscode에서 자동완성되는 for-in문의 스니팻을 보면 Object.hasOwnProperty.call를 사용하고 있다.for (const key in object) { if (Object.hasOwnProperty.call(object, key)) { const element = object[key]; }}그 이유는 자바스크립트가 프로퍼티의 명칭으로서 hasOwnProperty를 보호하지 않기 때문이다. 무슨말이냐 하면 아래 코드를 보자const foo = { hasOwnProperty: function () { return &#39;😭&#39; }, bar: &#39;🤣&#39;};foo.hasOwnProperty(&#39;bar&#39;); // (제대로 동작하지 않음) 항상 😭 리턴Object.prototype.hasOwnProperty.call(foo, &#39;bar&#39;); // (제대로 동작함) true 리턴foo 객체에 hasOwnProperty라는 key가 있기 때문에 기존 객체의 메서드가 동작하지 않는다. 그렇기 때문에 객체의 프로토타입에서 직접 hasOwnProperty를 사용하는 것이 안전하다.이 부분은 eslint 규칙에 따라 에러를 미연에 방지할 수 있다." }, { "title": "FEConf Korea - 컴포넌트, 다시 생각하기", "url": "/posts/feconf-component/", "categories": "클린코드", "tags": "클린코드", "date": "2022-02-03 21:38:00 +0900", "snippet": " 해당 글은 FEConf Korea - 컴포넌트, 다시 생각하기 영상을 보고 정리한 글 입니다.의존성 케이크를 만드려면 밀가루, 설탕, 계란이 필요하다. 케이크는 밀가루, 설탕, 계란에 의존한다. 라는 말과 같은 의미이다. 케이크의 의존성: 밀가루, 설탕, 계란위의 3 문장은 모두 같은 의미이다. 그렇다면 리액트 컴포넌트를 만들려면 어떤 것들이 필요할까?리액트 컴포넌트는 필요한 것들을 Props나 Hooks, import를 통해 받을 수 있다. 이 요소들은 리액트 컴포넌트가 가진 의존성의 기능적 분류라고 볼 수 있다.그럼 이러한 요소들은 어떤 특징을 가지고 있을까? 스타일 - css, scss 등등 컴포넌트에서 쓰이는 특정한 커스텀 로직 - UI를 조작하는 특정한 동작, 리액트 컴포넌트에 의도한 사이드 이펙트를 주거나 할 때 사용, 보통 커스텀 훅의 형태로 작성한다. 전역상태 - 유저액션을 통해 초래된 클라이언트의 상태이다. 보통 로그인 정보, URI 표현, 전체메뉴 열고 닫기 등등 리모트 데이터 스키마 - API 서버에서 내려주는 데이터.리팩토링비슷한 관심사라면 가까운 곳에 두기 어떤 부분을 수정할 때 파일들이 서로 멀어지면 집중력이 분산된다. 같은 파일 안에 두거나 바로 옆에 두는 것이 좋다. 아래와 같은 구조가 있을 때 어떠한 것을 서로 가까이 둘 수 있을까? 전역 상태는 여러 컴포넌트가 함께 사용하는 것이기 때문에 함께 두기 힘들 것이다. 스타일 (CSS in js)과 로직은 함께 두는 것을 쉽게 할 수 있을 것이다. 하지만 한 컴포넌트의 크기가 너무 커지게 되는 것을 걱정할 수 있는데 그럴 경우 상위나 하위의 폴더가 아닌 같은 폴더내에 다른 파일로 분리하자리모트 데이터 스키마와의 의존성API 서버로부터 리모트 데이터 스키마가 내려오는 모습을 보면, 루트 컴포넌트 -&amp;gt; 다른 컴포넌트 -&amp;gt; 내 컴포넌트의 흐름으로 흐르는 것을 볼 수 있다.여기서 만약 props를 통해 데이터 스키마를 받게 된다면 아래와 같은 모습일 것이다.이럴 경우 루트 컴포넌트와 강한 의존성이 생기게 된다.이것을 개선해 보면 아래와 같이 props를 통해 ID만 받고 데이터 저장소에서 해당ID를 통해 데이터를 받아올 수 있게 해서 의존성을 끊어낼 수 있다.import { useArticle } from &#39;~/store&#39;;interface Props { articleId: string;}const Something: React.ExoticComponent&amp;lt;Props&amp;gt; = (props) =&amp;gt; { const article = useArticle(props.articleId); return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;{article.title}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; )}데이터를 ID 기반으로 정리하기만약 API 응답이 다음과 같이 온다고 가정해 보자{ id: &#39;123&#39;, author: { id: &#39;1&#39;, name: &#39;paul&#39;, }, title: &#39;My awesome blog post&#39;, comments: [ { id: &#39;324&#39;, commenter: { id: &#39;2&#39;, name: &#39;Nicole&#39;, }, }, ],}여기서 ID기반으로 특정 객체에 접근한다고 한다면 쉽지 않을 것 같다. 그런데 다음과 같이 API 응답을 정리하면 어떨까?{ result: &#39;123&#39;, entities: { articles: { &#39;123&#39;: { id: &#39;123&#39;, author: &#39;1&#39;, title: &#39;My awesome blog post&#39;, comments: [&#39;324&#39;], }, }, users: { &#39;1&#39;: { id: &#39;1&#39;, name: &#39;Paul&#39; }, &#39;2&#39;: { id: &#39;2&#39;, name: &#39;Nicole&#39; }, }, comments: { &#39;324&#39;: { id: &#39;324&#39;, commenter: &#39;2&#39; }, }, },}모델명과 ID를 가지고 특정 데이터를 뽑아낼 수 있을 것이다. 이를 데이터 정규화(Normalization)라고 한다. 이런 데이터 정규화를 도와주는 normalizr라는 라이브러리가 있다.이렇게 리팩토링 함으로써 특정 객체를 데이터 저장소로부터 쉽게 가져올 수 있게 되었지만 여기에는 아직 또다른 숨은 의존성이 생기게 된다.바로 모델을 상위 컴포넌트에서 정확하게 알고있어야 한다는 점이다. 이것을 느슨하게 풀기 위해서 전역 ID (Global ID)를 사용하는 것이다.전역 ID는 특정 객체를 식별하기 위해 모델명을 따로 넘길 필요 없이 도메인 내에서 유일성을 갖는 ID를 말한다.보통 모델명과 ID값을 concat 하여 생성하거나 경우에 따라 base64 인코드, 디코드를 할 수도 있다.// Before// 해당 컴포넌트가 Article이라는 정보가 필요하다는 것 역시 컴포넌트 바깥에서 주입받고 있다.// import { useArticle } from &#39;~/store&#39;;// After// 전역 ID를 통해 데이터를 가져오는 훅import { useNode } from &#39;~/store&#39;;interface Props { articleId: string;}const Something: React.ExoticComponent&amp;lt;Props&amp;gt; = (props) =&amp;gt; { // Before // const article = useArticle(props.articleId); // After // 글로벌 아이디를 활용하여 사용할 데이터의 모델 정보 마저 컴포넌트 내부에 함께 둘 수 있다. const article = useNode({ on: &#39;Article&#39; }, props.articleId); return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;{article.title}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; )}Props 이름 짓기간단한 유저 프로필을 보여주는 컴포넌트가 있다. 이 컴포넌트는 게시물 위에도 붙을 수 있고, 친구 목록등에서 사용될 수 있다.이 컴포넌트의 리모트 데이터 스키마 의존성은 다음과 같다.이 컴포넌트는 유저 모델의 네임, 닉네임 등의 필드를 의존하고 있고, 유저 모델에 Image 필드가 가리키는 이미지 모델의 썸네일 url을 의존하고 있는 걸 확인할 수 있다.그럼 일단 단순하게 props 네이밍을 다음과 같이 해봤다.interface Props { leftImageThumbnailUrl: string; title: string; title2: string; caption: string; rightDotColor: string; rightCaption: string;}얼핏보면 직관적인것 같지만 사실은 그렇지 않다. 그 이유는 이 컴포넌트에 존재하는 의존성들을 명확하게 나타내 주지 않았기 때문이다.그래서 여기에 필요한 원칙은 의존한다면 그대로 드러내기이다.앞에 말했던 의존성을 드러내도록 props 네이밍을 다음과 같이 해보면, 유저와 이미지 모델을 사용하는 것을 그대로 드러냈다.interface Props { userImageThumbnailUrl: string; userName: string; userNickname: string; userTotalFollowerCount: string; userLastActivityAt: Date;}하지만 아직 여기에도 숨겨진 정보가 있다. 바로 유저와 이미지모델 사이의 관계 정보이다. 이 정보까지 드러내 보면 다음과 같은 모습이 될 것 이다.interface Props { user: { name: string; nickname: string; totalFollowerCount: string; lastActivityAt: Date; image: { thumbnailUrl: string; } }}훨씬 직관적인 모습이 되었다 👍그러나😱 한 컴포넌트에서 여러 모델(유저, 이미지)의 정보를 표현하는 것은 어쩌면 관심사의 분리가 제대로 안 되었다는 신호일 수 있다.따라서 이 컴포넌트를 유저와 이미지로 분리할 수 있다.하지만 이 부분도 상위 컴포넌트와 의존성(image의 thumbnailUrl)이 생길 것이라고 예상할 수 있다. 그렇기 때문에 아무래도 뭔가 재사용하기 힘들 것 같다.따라서 앞에서 소개한 전역 ID를 통해 필요한 객체의 래퍼런스만 받아오게 되면의존성이 느슨해지면서 훨씬 재사용성이 높아진 컴포넌트로 만들 수 있다.재사용 하기컴포넌트를 재사용하는 이유는 개발할 때 편리하기 위한 것보다 변경할 때 편리하기 위함 (유지보수)이라는 관점으로도 볼 수 있다.그럼 먼저 변경될 만한 부분을 미리 예측하고 아주 만반의 준비를 해야 한다.컴포넌트 변화의 방향성을 결정하는 것은 제품의 성격에 따라 다를수 있겠지만 대부분의 변화는 리모트 데이터 스키마가 변화하는 방향을 따라서 움직인다.그렇다면 이러한 리모트 데이터 스키마 변화에 어떻게 대응할 수 있을까?예를 들어 디자이너가 아래와 같은 스펙을 줬다고 가정해 보자.왼쪽은 위에서 봤던 유저를 표현하는 컴포넌트 였고, 오른쪽은 새로 추가된 페이지를 표현하는 컴포넌트 이다.이 둘은 얼핏봤을 때 상당히 비슷하게 생겼다. 하지만 이 둘이 의존하고 있는 리모트 스키마 데이터는 각각 유저, 페이지로 다르다.이런 상황에서 기존에 있던 컴포넌트를 재사용할지, 복사해서 새 컴포넌트로 분리할 지 어떤게 더 나은 방법일까?? 재사용 하는 경우 이와 같은 상황이라면 해당 컴포넌트를 사용하는 곳이 어디인지, 잘 수정되었는지 여러 군데를 테스트해야 할 것이고, 페이지만 따로 구별하기 힘들기 때문에 가볍게 대응하기 어려울 수 있다. 그래서 이 예시는 함께 변하면 안되는 것들이 특정 컴포넌트에 의존성으로 함께 존재하면서 발생했던 부작용 이슈를 잘 보여준다.그렇다면 함께 변해야하는 것들과 따로 변해야하는 것들을 어떻게 구별할 수 있을까?바로 모델 기준으로 컴포넌트를 분리하는 원칙이다. (같은 모델을 의존하는 컴포넌트의 경우 재사용하고, 다른 모델을 의존하는 컴포넌트는 별도로 분리한다.)최종 정리 비슷한 관심사라면 가까운 곳에 두기 데이터를 ID 기반으로 정리하기 의존한다면 그대로 드러내기 모델 기준으로 컴포넌트 분리하기" }, { "title": "2022-01-19 TIL", "url": "/posts/TIL/", "categories": "TIL", "tags": "Next.js", "date": "2022-01-19 17:54:00 +0900", "snippet": "getStaticProps getStaticProps는 서버측에서 실행 된다. Development 모드에서는 모든 요청에 대해 실행된다. Production 모드에서는 빌드 시 실행된다. pages에 있는 page 파일에서만 export 할 수 있다. 그 이유중 하나는 리액트는 페이지가 렌더링 되기 전에 필요한 모든 데이터를 가지고 있어야 하기 때문이다. 기본 Props로 context 객체를 받는다. context 객체 구성 요소 params: 만약 동적 라우팅을 사용하는 페이지라면 라우트 파라미터의 정보를 가지고 있다. req: HTTP request 객체 res: HTTP response 객체 query: 쿼리 스트링 preview previewData getStaticPaths 동적 라우팅을 사용하는 페이지의 경우 getStaticProps대신 getStaticPaths를 사용해야 한다. return 값으로 반드시 paths와 fallback을 명시해야 한다. paths에 정의하지 않은 경로에 접근할 경우 화면이 뜨지 않는다. fallback: false : paths 외의 경로는 404. fallback: true : paths 외의 경로로 요청이 들어오면 빌드 시 HTML로 렌더링 된다. ... 생략export const getStaticPaths = async () =&amp;gt; { const res = await fetch(&#39;posts를 가져오는 API&#39;) const posts = await res.json() // 프리 렌더링 할 Path의 목록을 가지고 있음 const paths = posts.map((post) =&amp;gt; ({ params: { id: post.id }, })) return { paths, fallback: false }}export const getStaticProps = async ({ params }) =&amp;gt; { const res = await fetch(`posts를 가져오는 API${params.id}`) const post = await res.json() return { props: { post } }} getServerSideProps 빌드와 상관없이 매 페이지 요청시 데이터를 서버에서 가져온다. 기본 Props로 context 객체를 받는다. context 객체 구성 요소 params: 만약 동적 라우팅을 사용하는 페이지라면 라우트 파라미터의 정보를 가지고 있다. req: HTTP request 객체 res: HTTP response 객체 query: 쿼리 스트링 preview previewData 페이지를 렌더링 하기 전에 반드시 fetch해야 할 데이터가 있을 때 사용한다. 매 페이지 요청시 호출되기 때문에 getStaticProps보다 느리지만 빌드 이후에도 실행된다. 서버에서 실행되고 브라우저에서 실행되지 않는다.API Routes Next.js로 쉽게 API를 만들수 있다. Next.js 서버에서 만든 API를 호출하여 프리 렌더링할 페이지에 해당 데이터를 넣어 SEO에 도움을 줄 수 있다. getStaticProps, getStaticPaths에서 직접 API Routes를 fetch하면 안된다. 그 이유는 getStaticProps, getStaticPaths는 서버 사이드에서 동작하기 때문이다. // pages/api/hello.js export function buildHelloPath() { return path.join(process.cwd(), &#39;data&#39;, &#39;hello.json&#39;); } export function extractHello(filePath) { const fileData = fs.readFileSync(filePath); const data = JSON.parse(fileData); return data; } export default function handler(req, res) { if (req.method === &#39;POST&#39;) { const { email, text } = req.body; const newHelloData = { id: new Date().toISOString(), email, text, }; // store that in a database or in a file; const filePath = buildHelloPath(); const data = extractHello(filePath); data.push(newHelloData); fs.writeFileSync(filePath, JSON.stringify(data)); res.status(201).json({ message: &#39;Success!&#39;, helloData: newHelloData }); } else { const filePath = buildHelloPath(); const data = extractHello(filePath); res.status(200).json({ helloData: data }); } } // pages/hello.js import { buildHelloPath, extractHello } from &#39;../api/hello&#39;; export default function HelloPage({ helloItems }) { return ( &amp;lt;ul&amp;gt; {helloItems.map(item =&amp;gt; ( &amp;lt;li key={item.id}&amp;gt;{item.text}&amp;lt;/li&amp;gt; ))} &amp;lt;/ul&amp;gt; ) } export async function getStaticProps() { // API Routes를 여기서 직접 사용하면 안되고 api/hello.js에서 작성한 함수를 import해서 사용한다. const filePath = buildFeedbackPath(); const data = extractFeedback(filePath); return { props: { helloItems: data, }, } } " }, { "title": "Layout Shift 피하기", "url": "/posts/web-optimization-layout-shift/", "categories": "웹 성능 최적화", "tags": "Layout Shift", "date": "2022-01-11 22:08:00 +0900", "snippet": "Layout Shift란?단어 그대로 화면상에서 어떤 각 요소들이 로딩 속도나 다른 이유를 통해 화면에 보여지는 시점이 달라지면서 발생하는 요소 밀림 현상을 말한다.크롬 개발자 도구의 성능탭에서도 확인할 수 있다. 빨간색으로 표시된 부분에 마우스를 올리면 친절하게도 어떤 요소에 Layout Shift가 발생했는지 확인할 수 있다.Layout Shift는 당연히 성능, 사용자 경험에 영향을 끼친다. 그 이유는 이 현상이 일어나는 것 자체가 화면상에서 위치값을 다시 계산하는 것이기 때문이다.개발자도구에서도 Layout Shift(레이아웃 변경)이 일어나면 레이아웃, 페인트가 발생하는 것을 확인할 수 있다.Layout Shift의 원인 사이즈가 지정되지 않은 이미지 동적으로 삽입된 컨텐츠 웹 폰트 (FOIT, FOUT)이 현상을 해결하기 위해선 간단하다 Layout Shift가 발생할 것 같은 요소에 사이즈를 지정하는 것이다.이미지를 비율에 맞춰 렌더링 하는 방법const ImageWrapper = styled.div` position: relative; width: 100%; /* 16:9로 맞추기 위해 9/16 === 0.5625 =&amp;gt; 56.25% */ /* 너비의 56.25% 만큼 세팅 */ padding-bottom: 56.25%;`;const Image = styled.img` position: absolute; cursor: pointer; width: 100%; height: 100%; top: 0; left: 0;`;// 생략return ( &amp;lt;ImageWrapper&amp;gt; &amp;lt;Image src={image.src} alt={image.alt} /&amp;gt; &amp;lt;/ImageWrapper&amp;gt;);위 코드와 같이 Image 컴포넌트를 감싸는 ImageWrapper에 원하는 비율 or 크기를 미리 지정해 주고 이미지는 자신을 감싸고 있는 부모의 크기를 갖기 위해 width, height 모두 100%로 지정해 주고 position을 absolute로 하여 ImageWrapper영역이 깨지지 않도록 한다.물론 이 방법 외에도 여러 방법들이 있을 것이다!" }, { "title": "CSS 최적화", "url": "/posts/web-optimization-css/", "categories": "웹 성능 최적화", "tags": "CSS 최적화", "date": "2022-01-09 10:30:00 +0900", "snippet": "다른 요소들과 마찬가지로 CSS도 최적화를 할 수 있다.개발자도구의 커버리지탭을 보면 각 요소들에 대한 사용량을 보여준다. (빨간색 그래프가 사용하지 않는 부분임)해당 내용을 더 자세하게 보기 위해선 위에 소스탭을 켜두고 자세히 보고자 하는 요소를 아래 커버리지탭에서 클릭하면 확인할 수 있다.여기도 마찬가지로 빨간색과 파란색으로 표시된다.사용하지 않는 CSS 코드를 줄이는 방법사용하지 않는 CSS 코드를 줄이는 방법은 여러가지가 있는데 먼저 PurgeCSS를 사용하는 방법에 대해 알아보겠다.친절하게도 공식사이트에 설명이 되어 있다. 하나씩 따라가보자 yarn add -D purgecss purge를 실행하는 스크립트 명령어 추가 &quot;purge&quot;: &quot;purgecss --css ./build/static/css/*.css --output ./build/static/css/ --content ./build/index.html ./build/static/js/*.js&quot; –css: 어떤 css 파일들을 대상으로 할 건지 –output: 결과물을 내보내는 디렉토리 (지금은 해당 결과물을 기존 파일에 덮어 씌운다는 의미이다) –content: 어떤 컨텐츠와 비교할 건지 이렇게 끝나면 물론 좋겠지만 문제가 발생할 수도 있다. 그 문제는 purgecss를 실행 시키고 나서 스타일이 깨질 수 있기 때문이다. 예를 들어 tailwindcss를 사용할 경우 lg:md-8과 같은 클래스 명을 사용할 수 있다. 하지만 purge가 클래스명을 분석할 때 lg:md-8을 통째로 분석하는 것이 아니라 lg, md-8 각각 따로 분석할 수도 있기 때문에 해당 부분에 css가 제대로 적용되지 않을 수 있다.이 문제를 해결하기 위해선 configuration 문서를 살펴보자interface UserDefinedOptions { content: Array&amp;lt;string | RawContent&amp;gt;; css: Array&amp;lt;string | RawCSS&amp;gt;; // 이 부분이 우리가 필요한 부분이다 defaultExtractor?: ExtractorFunction; extractors?: Array&amp;lt;Extractors&amp;gt;; fontFace?: boolean; keyframes?: boolean; output?: string; rejected?: boolean; stdin?: boolean; stdout?: boolean; variables?: boolean; safelist?: UserDefinedSafelist; blocklist?: StringRegExpArray;} purgecss.config.js 파일을 생성한다 module.exports = { // content는 우리가 지정한 content 파일을 의미한다. // 어디까지 클래스 네임으로 인정할 것인지 정규표현식으로 설정해야 한다. // \\w : [0-9a-zA-Z_] defaultExtractor: content =&amp;gt; content.match(/[\\w\\:\\-]+/g) || [], }; config 파일을 추가했기에 스크립트 명령어로 아래와 같이 수정한다. &quot;purge&quot;: &quot;purgecss --css ./build/static/css/*.css --output ./build/static/css/ --content ./build/index.html ./build/static/js/*.js --config ./purgecss.config&quot; 결과Passed 😁" }, { "title": "SLASH 21 - 실무에서 바로 쓰는 Frontend Clean Code", "url": "/posts/slash-21-cleancode/", "categories": "클린코드", "tags": "클린코드", "date": "2022-01-07 19:12:00 +0900", "snippet": " 해당 글은 SLASH 21 - 실무에서 바로 쓰는 Frontend Clean Code 영상을 보고 정리한 글 입니다.안일한 코드 추가의 함정유지보수할 때 안일한 코드 추가의 함정에 대해 알아보자상황 기능 추가 요청이 들어왔다 추가 요구사항은 다음과 같다 보험에 대한 질문을 입력하는 페이지가 있는데 내 설계사가 있는 경우에는 설계사 사진이 들어간 팝업을 먼저 띄워주세요 기존 코드 파악const QuestionPage = () =&amp;gt; { const handleQuestionSubmit = async () =&amp;gt; { const 약관동의 = await 약관동의_받아오기(); if (!약관동의) { await 약관동의_팝업열기(); } await 질문전송(questionValue); alert(&#39;질문이 등록되었습니다.&#39;); }; return ( &amp;lt;main&amp;gt; &amp;lt;form&amp;gt; &amp;lt;textarea placeholder=&#39;어떤 내용이 궁금한가요?&#39; /&amp;gt; &amp;lt;button onClick={handleQuestionSubmit}&amp;gt;질문하기&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/main&amp;gt; );};export default QuestionPage; 질문하기 버튼을 클릭하면 유저의 약관동의 여부를 검사하고 필요하다면 팝업을 띄운다 질문을 전송하고 성공 Alert를 띄운다이 코드에 새 기능을 어떻게 추가하면 될까?클릭함수에서 내 설계사가 있으면 팝업 띄우는 로직을 추가하고 팝업 컴포넌트를 추가하면 된다.const QuestionPage = () =&amp;gt; { // 팝업 Open 여부 상태 추가 const [popupOpened, setPopupOpened] = useState(false); const handleQuestionSubmit = async () =&amp;gt; { // 내설계사를 검사하는 조건문 추가 const 내설계사 = await 내설계사_받아오기(); if (내설계사 !== null) { setPopupOpened(true); } else { const 약관동의 = await 약관동의_받아오기(); if (!약관동의) { await 약관동의_팝업열기(); } } await 질문전송(questionValue); alert(&#39;질문이 등록되었습니다.&#39;); }; // 팝업내 확인 버튼 핸들러 추가 const handleMyExpertQuestionSubmit = async () =&amp;gt; { await 내설계사_질문전송(questionValue, 내설계사.id); alert(`${내설계사.name}에게 질문이 등록되었습니다.`); }; return ( &amp;lt;main&amp;gt; &amp;lt;form&amp;gt; &amp;lt;textarea placeholder=&#39;어떤 내용이 궁금한가요?&#39; /&amp;gt; &amp;lt;button onClick={handleQuestionSubmit}&amp;gt;질문하기&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; {/* 팝업 컴포넌트 추가 */} {popupOpened &amp;amp;&amp;amp; &amp;lt;내설계사팝업 onSubmit={handleMyExpertQuestionSubmit} /&amp;gt;} &amp;lt;/main&amp;gt; );};export default QuestionPage;요구사항 추가 후 문제점이렇게 요구사항이 추가된 코드를 봤을 때 타당하고 자연스러운 코드 추가처럼 보이지만 나쁜코드가 되었고 그 이유에 대해 살펴보자.1. 하나의 목적인 코드가 흩어져 있다.내 설계사팝업 관련된 코드는 아래 사진과 같이 표시된 부분이다.이것들이 다 떨어져 있기 때문에 나중에 또 다른 기능을 추가할 때 스크롤을 위아래로 이동하며 로직을 살펴봐야 한다.2. 하나의 함수가 여러가지 일을 하고 있다기존에 있던 함수 handleQuestionSubmit함수가 3가지 일을 하고 있다. 그래서 세부 구현 내용을 모두 읽어야 이 함수의 역할을 알 수 있게 된다, 이렇게 되면 나중에 코드를 추가하거나 삭제할 때 시간이 더 걸리게 될 것이다.3. 함수의 세부 구현 단계가 제각각이다그림에 표시된 두 함수는 이벤트 핸들링 함수이다. 함수의 이름도 각각 handleQuestionSubmit, handleMyExpertQuestionSubmit로 비슷하다.하지만 첫 번째 함수는 질문전송 외에 여러가지 일을 하고 있기 때문에 읽기 어지럽다. 그래서 코드를 이상하게 지레짐작할 수 있다. 그 때는 맞고 지금은 틀리다처음 깔끔했던 코드와 다르게 작은 기능을 추가했더니 어지러운 코드가 되어버렸다. 🤪😵여기서의 함정은 Pull Request에서 봤을 땐 이것이 어지러운 코드라는 걸 파악하기 어려웠을 것이다. 변경점 자체에는 틀린 점이 없기 때문이다. 하지만 코드 전체를 본다면 엉망인 코드이다.리팩토링 하기1. 함수의 세부 구현 단계 통일기존 handleQuestionSubmit함수의 이름을 handleNewExpertQuestionSubmit로 변경후 새로운 설계사에게 질문하는 로직만 넣어 handleMyExpertQuestionSubmit함수와 세부 구현 단계를 통일했다2. 하나의 목적인 코드는 뭉쳐 두기기존에는 팝업을 여는 버튼과 팝업 코드가 떨어져있었는데 팝업 관련 코드를 하나로 합쳤다 (PopupTriggerButton 컴포넌트)3. 함수가 한 가지 일만 하도록 쪼개기약관동의 관련 함수를 쪼개서 필요한 시점에 부르도록 하였다리팩토링 된 코드... 생략const handleNewExpertQuestionSubmit = async () =&amp;gt; { await 질문전송(questionValue); alert(&#39;질문이 등록되었습니다.&#39;);};const handleMyExpertQuestionSubmit = async () =&amp;gt; { await 내설계사_질문전송(questionValue, 내설계사.id); alert(`${내설계사.name}에게 질문이 등록되었습니다.`);};const openPopupToNotAgreedUser = async () =&amp;gt; { const 약관동의 = await 약관동의_받아오기(); if (!약관동의) { await 약관동의_팝업열기(); }};return ( &amp;lt;main&amp;gt; &amp;lt;form&amp;gt; &amp;lt;textarea placeholder=&#39;어떤 내용이 궁금한가요?&#39; /&amp;gt; {내설계사.connected ? ( &amp;lt;PopupTriggerButton popup={&amp;lt;내설계사팝업 onButtonSubmit={handleMyExpertQuestionSubmit} /&amp;gt;} &amp;gt; 질문하기 &amp;lt;/PopupTriggerButton&amp;gt; ) : ( &amp;lt;button onClick={async () =&amp;gt; { await openPopupToNotAgreedUser(); await handleNewExpertQuestionSubmit(); }} &amp;gt; 질문하기 &amp;lt;/button&amp;gt; )} &amp;lt;/form&amp;gt; &amp;lt;/main&amp;gt;);... 생략리팩토링 된 코드가 조금 더 길어졌다. 그 이유는 클린코드는 짧은 코드가 아니라 원하는 로직을 빠르게 찾을 수 있는 코드이기 때문이다.로직을 빠르게 찾을 수 있는 코드원하는 로직을 빨리 찾기 위해선 다음과 같은 단계가 필요하다 응집도 - 하나의 목적을 가진 코드를 모은다. 단일책임 - 함수가 하나의 일만 하도록 한다. 추상화 - 함수의 세부구현 단계가 제각각 일 때는 추상화 단계를 조정해서 핵심 개념을 필요한 만큼 노출해야 한다.응집도같은 목적인 코드는 뭉쳐두자!const QuestionPage = () =&amp;gt; { // 팝업 조작 1 const [popupOpened, setPopupOpened] = useState(false); const handleClick = () =&amp;gt; { setPopupOpened(true); }; // 팝업 조작 2 const handlePopupSubmit = async () =&amp;gt; { await 질문전송(연결전문가.id); alert(&#39;질문을 전송했습니다.&#39;); }; return ( &amp;lt;&amp;gt; &amp;lt;button onClick={handleClick}&amp;gt;질문하기&amp;lt;/button&amp;gt; {/* 팝업 조작 3 */} &amp;lt;Popup title=&#39;보험 질문하기&#39; open={popupOpened}&amp;gt; &amp;lt;div&amp;gt;전문가가 설명해드려요&amp;lt;/div&amp;gt; &amp;lt;button onClick={handlePopupSubmit}&amp;gt;확인&amp;lt;/button&amp;gt; &amp;lt;/Popup&amp;gt; &amp;lt;/&amp;gt; );};export default QuestionPage;팝업을 조작하는 코드가 이렇게 세 군데에 서로 떨어져 있다. 그렇기 때문에 파악도 한 번에 안되고 버그 발생 위험이 높은 코드이다.리팩토링 v1const QuestionPage = () =&amp;gt; { const [openPopup] = useMyExpertPopup(연결전문가.id); const handleClick = () =&amp;gt; { setPopupOpened(true); }; return &amp;lt;button onClick={handleClick}&amp;gt;질문하기&amp;lt;/button&amp;gt;;};export default QuestionPage;커스텀 훅을 사용해서 한 군데로 뭉쳤기 때문에 openPopup 함수만 호출하면 팝업을 열 수 있게 되었다. 하지만 오히려 읽기 힘든 코드가 되었다. 어떤 내용의 팝업을 띄우는지, 팝업에서 버튼을 눌렀을 때 어떤 액션을 하는지가 이 페이지에서 가장 중요한 포인트 인데 커스텀 훅 속에 가려져서 한 번에 알 수 없게 되었다.이것이 커스텀 훅의 대표적인 안티패턴이다.그렇다면 무엇을 뭉쳐야 좋은 코드가 되는 걸까? 🤔 뭉치면 쾌적한 코드 당장 몰라도 되는 디테일 이것을 숨겨둔다면 짧은 코드만 보고도 빠르게 코드의 목적을 파악하는게 쉬워진다 뭉치면 답답한 코드 코드 파악에 필수적인 핵심 정보 이를 분리해 두면 여러 모듈을 넘나들며 흐름을 따라가야 하기 때문이다 뭉쳐서 짧은 코드로 만든다고 코드가 깨끗해지는 것은 아니다!코드 응집 TIP!핵셈 데이터와 세부 구현나누기const QuestionPage = () =&amp;gt; { // 세부 구현 1 - 팝업을 열고 닫을 때 사용하는 상태 const [popupOpened, setPopupOpened] = useState(false); const handleClick = () =&amp;gt; { setPopupOpened(true); }; // 핵심 데이터 1 - 팝업 버튼 클릭 시 수행하는 액션 const handlePopupSubmit = async () =&amp;gt; { await 질문전송(연결전문가.id); alert(&#39;질문을 전송했습니다.&#39;); }; return ( &amp;lt;&amp;gt; &amp;lt;button onClick={handleClick}&amp;gt;질문하기&amp;lt;/button&amp;gt; {/* 핵심 데이터 2 - 팝업의 제목, 내용 */} {/* 세부 구현 2 - 컴포넌트의 세부 마크업, 팝업 버튼 클릭 시 특정 함수를 호출하는 바인딩 */} &amp;lt;Popup title=&#39;보험 질문하기&#39; open={popupOpened}&amp;gt; &amp;lt;div&amp;gt;전문가가 설명해드려요&amp;lt;/div&amp;gt; &amp;lt;button onClick={handlePopupSubmit}&amp;gt;확인&amp;lt;/button&amp;gt; &amp;lt;/Popup&amp;gt; &amp;lt;/&amp;gt; );};export default QuestionPage;여기서 핵심 데이터만 남기고 세부 구현을 숨기면 파악하기 쉬운 코드가 된다.리팩토링 v2핵심 데이터는 밖에서 전달하고, 나머지는 뭉친다.const QuestionPage = () =&amp;gt; { const [openPopup] = usePopup(); const handleClick = async () =&amp;gt; { // 핵심 데이터 2 - 팝업의 제목, 내용 const confirmed = await openPopup({ title: &#39;보험 질문하기&#39;, contents: &amp;lt;div&amp;gt;전문가가 설명드려요&amp;lt;/div&amp;gt;, }); if (confirmed) { // 핵심 데이터 1 - 팝업 버튼 클릭 시 수행하는 액션 await submitQuestion(); } }; const submitQuestion = async 연결전문가 =&amp;gt; { await 질문전송(연결전문가.id); alert(&#39;질문을 전송했습니다.&#39;); }; return &amp;lt;button onClick={handleClick}&amp;gt;질문하기&amp;lt;/button&amp;gt;;};export default QuestionPage;usePopup 커스텀 훅 안에 모든 코드를 다 숨기는 것이 아니라 세부 구현만 숨겨놓고 핵심 데이터인 팝업 제목, 내용, 액션은 밖에서 넘긴다. 그러면 세부 구현을 읽지 않고도 어떤 팝업인지 파악할 수 있다. 팝업, 너에게 선언한다! 제목은 보험 질문하기, 내용은 전문가가 설명드려요, 확인버튼 클릭하면 질문을 제출해라!라고 선언하면 팝업이 이미 해둔 세부 구현을 바탕으로 해당 내용을 뿌려준다. 이것을 선언형 프로그래밍이라고 한다 (핵심 데이터만 전달받고 세부 구현은 뭉쳐 숨겨 두는 개발 패턴)이 패턴의 특징은 무엇을 하는 함수인지 빠르게 이해가 가능하고, 세부 구현은 안쪽에 두웠기 때문에 신경쓸 필요가 없고, 마지막으로 무엇만 바꿔서 쉽게 재사용이 가능하다.이 패턴과 상반되는 개념으로는 명령형 프로그래밍이 있다. 이것은 어떻게 해야 할지 하나하나 명령하여 코드를 작성하는 패턴이다. 선언형 프로그래밍도 내부는 명령형 프로그래밍으로 되어있다.세부 구현이 모두 노출되어 있기 때문에 이를 커스텀하기 쉽지만 읽는 데 오래 걸리고 재사용하기 어렵다.Q. 그럼 선언형 프로그래밍으로 작성된 코드가 무조건 좋은가? A. 아니다. 두 방법을 유동적으로 사용하면 된다.단일책임하나의 일을 하는 뚜렷한 이름의 함수를 만들자함수의 이름을 정할 때 중요 포인트가 담겨있지 않은 함수명은 읽는 사람이 예상한 대로 코드가 동작하지 않기 때문에 코드에 대한 신뢰 하락으로 이어진다. 그 다음부터는 함수명을 믿지 못하게 된다.리액트 컴포넌트로 기능을 분리할 수도 있다. 버튼을 클릭하면 서버에 로그를 찍는 코드Before&amp;lt;button onClick={async () =&amp;gt; { log(&#39;제출 버튼 클릭&#39;); await openConfirm();}}&amp;gt;버튼 클릭 함수에 로그 찍는 함수와 API를 호출하는 함수가 섞여 있다.&amp;lt;/br&amp;gt;After&amp;lt;LogClick message=&#39;제출 버튼 클릭&#39;&amp;gt; &amp;lt;button onClick={openConfirm}&amp;gt;&amp;lt;/LogClick&amp;gt;로그는 버튼을 감싼 컴포넌트에서 찍고, 버튼 클릭함수에서는 API 호출만 신경쓴다. IntersectinObserverBeforeconst targetRef = useRef(null); useEffect(() =&amp;gt; { const observer = new IntersectionObserver(([{ isIntersecting }]) =&amp;gt; { if (isIntersecting) { fetchSomething(nextPage); } }); return () =&amp;gt; { observer.unobserve(targetRef.current); }; }, []);이 코드는 옵저버 코드 세부구현과 API 호출로직이 섞여 있어 조금 아쉬운 코드이다.After&amp;lt;IntersectionArea onImpression={() =&amp;gt; fetchSomething(nextPage)}&amp;gt; &amp;lt;div&amp;gt;더 보기&amp;lt;/div&amp;gt;&amp;lt;/IntersectionArea&amp;gt;옵저버 코드 세부구현은 IntersectionArea 컴포넌트에 숨겨두고 사용하는 입장에서는 API 호출만 신경쓴다. 조건이 많아지면 한글 변수명도 유용하다. 도메인이 복잡해서 영어 이름 길게 짓는 게 오히려 복잡도를 높일 때 상수를 직관적으로 보고 싶을 때 복잡한 조건문이 많아질 때 마치 주석을 달아둔 것과 같은 효과도 낸다. 코드가 약간 귀엽다(?) 😄 추상화Before&amp;lt;div style=&amp;gt; &amp;lt;button onClick={async () =&amp;gt; { const res = await 회원가입(); if (res.success) { 프로필로이동(); } }}&amp;gt; 전송 &amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;팝업 컴포넌트 코드를 제로부터 디테일 하게 구현&amp;lt;/br&amp;gt;After&amp;lt;Popup onSubmit={회원가입} onSuccess={프로필로이동}/&amp;gt;제출액션, 성공액션이라는 중요한 개념만 남기고 나머지를 추상화 했다.그럼 어느 단계까지 추상화를 해야 할까?? 구체적인 코드를 조금 추상적이게, 혹은 더욱 추상적이게 리팩토링 할 수 있다.Level 0&amp;lt;button onClick={showConfirm}&amp;gt; 전송&amp;lt;/button&amp;gt;{isShowConfirm &amp;amp;&amp;amp; ( &amp;lt;Confirm onClick={() =&amp;gt; {showMessage(&#39;성공&#39;)}}&amp;gt;)}버튼을 클릭하면 컨펌 창을 띄우고, 여기서 컨펌 버튼을 클릭하면 특정 메시지를 띄우는 구체적인 코드가 있다.Level 1&amp;lt;ConfirmButton onConfirm={() =&amp;gt; showMessage(&#39;성공&#39;)}&amp;gt; 전송&amp;lt;/ConfirmButton&amp;gt;버튼을 눌렀을 때 컨펌창을 띄우는 기능을 ConfirmButton 컴포넌트로 추상화 했다. onConfirm을 통해 개발자가 원하는 액션을 넘길 수 있다.Level 2&amp;lt;ConfirmButton message=&quot;성공&quot;&amp;gt; 전송&amp;lt;/ConfirmButton&amp;gt;message라는 prop만 넘겨서 컨펌창에 원하는 메시지를 보여주도록 더 간단하게 추상화 할 수 있다.Level 3&amp;lt;ConfirmButton /&amp;gt;더 나아가 모든 기능을 ConfirmButton 컴포넌트로 추상화 시킬수도 있다.정답은 없다! 상황에 따라 필요한 만큼 추상화 하면 된다.하지만 추상화 수준(레벨)이 한 코드파일 안에서 섞여 있으면 코드 파악이 오히려 어려워 질 수 있다.// 높은 추상화&amp;lt;Title&amp;gt;별점을 매겨주세요&amp;lt;/Title&amp;gt;// 낮은 추상화&amp;lt;div&amp;gt; {STARS.map(() =&amp;gt; &amp;lt;Star /&amp;gt;)}&amp;lt;/div&amp;gt;// 높은 추상화&amp;lt;Review /&amp;gt; // 중간 추상화{rating !== 0 &amp;amp;&amp;amp; ( &amp;lt;&amp;gt; &amp;lt;Agreement /&amp;gt; &amp;lt;Button rating={rating}&amp;gt; &amp;lt;/&amp;gt;)}앞으로 우리가 해야할 행동 담대하게 기존 코드 수정하기 두려워하지 말고 기존 코드를 씹고 뜯고 맛보고 즐기자 구조 뜯기를 두려워 하면, 클린한 실무 코드를 유지할 수 없다 큰 그림 보는 연습하기 그 때는 맞고 지금은 틀릴 수 있다라는 것을 생각하자 기능 추가 자체는 클린해도, 전체적으로는 어지러울 수 있다 기존에 깨끗하던 코드에 내가 기능을 추가하면서 망쳐놓을 수 있다 팀과 함께 공감대 형성하기 코드에 정답은 없다 명시적으로 이야기를 하는 시간이 필요하다 문서로 적어보기 글로 적어야 명확해진다 향후 어떤 점에서 위험할 수 있는지 어떻게 개선할 수 있는지 " }, { "title": "캐시 최적화", "url": "/posts/web-optimization-cache/", "categories": "웹 성능 최적화", "tags": "캐시 최적화", "date": "2022-01-07 13:02:00 +0900", "snippet": "크롬 개발자 도구의 lighthouse를 실행시켜 보면 아래와 같이 Serve static assets with an efficient cache policy라는 항목을 만날 수 있다이 의미는 정적 파일들에 대해 캐시처리가 안되어 있을 경우 나타나는 것인데 이를 해결하기 위해 Cache-Control이라는 것을 사용해야 한다Cache-Control캐시를 적용하려면 브라우저가 서버로 특정 리소스를 요청할 때 서버에 해당 리소스의 캐시를 적용해 달라라는 요청을 해야 하는데 그것이 바로 Http Header에 들어가는 Cache-Control이다하지만 클라이언트 쪽에서 Cache-Control 요청을 한다고 해서 바로 캐시를 적용할 수 있는 것은 아니다. 그 이유는 서버에서 별도로 설정을 해야 하기 때문이다Cache-Control에 설정할 수 있는 옵션 no-cache : 캐시를 사용하기 전에 서버에서 사용 가능한 지 검사 후 사용 유무를 결정한다 no-store : 캐시를 사용 안함 public : 모든 환경에서 캐시 사용 private : 브라우저 환경에서만 캐시를 사용 (외부 캐시 서버에서는 사용 불가) max-age : 캐시 유효시간 (초 단위)사용 예시 cache-control: max-age=120 cache-control: public, max-age=600 cache-control: no-cache (max-age=0과 같은 의미이다 -&amp;gt; max-age가 0이어도 브라우저에서 캐시를 바로 버리는 것이 아니라 가지고 있다. 즉, 만료가 되었다고 해서 서버에서 바로 해당 리소스를 불러오는 것이 아니라 서버에서 사용 가능한지 검사 후 사용 유무에 따라 결정되기 때문이다)그럼 서버는 어떻게 브라우저가 가지고 있는 캐시데이터가 서버에 있는 최신의 데이터가 같은지 판단할 수 있을까?바로 etag로 판단할 수 있다 etag는 해당 리소스에 대한 hash값이라고 생각하면 된다" }, { "title": "폰트 최적화", "url": "/posts/web-optimization-font/", "categories": "웹 성능 최적화", "tags": "폰트 최적화", "date": "2022-01-05 16:35:00 +0900", "snippet": "웹 폰트의 문제점웹 폰트를 사용할 경우 두 가지의 문제점이 있다 FOUT(Flash of Unstyled Text) 폰트가 다운로드 되기 전에는 기본 폰트로 보인다 폰트가 다운로드가 완료 되어야 폰트가 적용 된다 IE, Edge FOIT(Flash of Invisible Text) 폰트가 다운로드 되기 전에는 화면에서 Text를 안보여 준다 폰트가 다운로드 완료 되어야 화면에 보인다 Chrome, Safari 폰트 최적화 방법먼저, 폰트 최적화의 궁극적인 목표는 FOUT와 FOIT를 최소화 하는 것이다. 그럼 어떻게 최적화를 할 수 있을까? 크게 2가지의 방법이 있는데 다음과 같다 폰트 적용 시점 컨트롤 FOUT를 선택할 것인지, FOIT를 선택할 것인지, 둘다 혼합할지, 아니면 아예 새로운 방법을 선택할지 상황에 맞게 개발자가 컨트롤 하는 것이다 폰트 사이즈 줄이기 폰트 사이즈를 물리적으로 줄여 다운로드 속도를 빠르게 하는 것이다 폰트 적용 시점 컨트롤이것을 컨트롤 하기 위해선 css의 font-display라는 속성을 사용해야 한다font-display auto : 브라우저 기본 동작 block : FOIT (timeout = 3초) 여기서 timeout의 의미는 폰트를 다운로드 받는 데 3초가 지나면 기본 폰트를 보여준다는 의미 swap : FOUT fallback : FOIT (timeout = 0.1초), 만약 3초 이후에도 불러오지 못했을 경우 기본 폰트로 유지한다 즉, 3초 이후에는 사용자에게 깜빡임을 보여주지 않는다. 다운로드가 완료되면 폰트를 캐시해놓는다 optional : FOIT (timeout = 0.1초), 네트워크 상황에 따라 기본폰트로 유지할지 웹폰트를 적용할지 결정하고 이후에 캐시한다 (구글에서 권장하는 방법이다)만약 FOIT를 사용할 경우 사용자 경험을 조금이라도 좋게하는 트릭을 사용할 수 있는데 그것은 폰트 다운로드가 완료되는 시점에 fade-in효과를 주는 것이다폰트의 다운로드 여부를 알기 위해서 Font Face Observer 라이브러리의 도움을 받을 수 있다const Component = () =&amp;gt; { const [isFontLoaded, setIsFontLoaded] = useState(false); useEffect(() =&amp;gt; { const font = new FontFaceObserver(&#39;font family&#39;); // 사용하는 font family를 명시 font.load().then(() =&amp;gt; { setIsFontLoaded(true); }); }, []); return ( ... 생략 )}폰트 사이즈 줄이기 ttf가 아닌 효율적인 웹 폰트 사용 WOFF, WOFF2 등등 EOT, TTF/OTF, WOFF, WOFF2 중에서는 WOFF2가 파일 크기가 가장 작다 https://transfonter.org/ 이곳에서 폰트 변환을 할 수 있다 WOFF2, WOFF등을 사용할 때 미지원하는 브라우저가 있을 수 있으므로 아래와 같이 적용한다 @font-face { font-family: Your Font Family; src: url(&#39;./assets/fonts/Your Font File.woff2&#39;) format(&#39;woff2&#39;), url(&#39;./assets/fonts/Your Font File.woff&#39;) format(&#39;woff&#39;), url(&#39;./assets/fonts/Your Font File.ttf&#39;) format(&#39;truetype&#39;); font-display: block; } local 폰트 사용 사용자 PC에 해당 폰트가 설치되어 있을 경우 local()을 사용하여 다운로드 없이 바로 사용할 수 있다. @font-face { font-family: Your Font Family; src: local(&#39;Your Font Family&#39;), url(&#39;./assets/fonts/Your Font File.woff2&#39;) format(&#39;woff2&#39;), url(&#39;./assets/fonts/Your Font File.woff&#39;) format(&#39;woff&#39;), url(&#39;./assets/fonts/Your Font File.ttf&#39;) format(&#39;truetype&#39;); font-display: block; } Subset 사용 폰트 파일에서 불필요한 글자를 제거하고 사용할 글자만 남겨둔 폰트이다 위에서 폰트를 변환했던 사이트 https://transfonter.org/ 에서 subset 설정도 할 수 있다 subset 뿐만 아니라 사용할 문자에 대해서도 지정할 수가 있다 Unicode Range 적용 css 속성중 unicode-range를 사용하여 옵션으로 지정한 유니코드에 대해서만 폰트를 적용한다는 의미이다 data-uri 변환 Preload 사용 웹에서 CSS가 로드가 되고 CSS를 읽는 순간 명시한 폰트가 필요하다는 것을 알게 되는데 그 시점보다 더 먼저 로드를 시키는 방법이다 HTML 파일의 HEAD 안에 명시해야 한다. &amp;lt;link rel=&quot;preload&quot; href=&quot;Your Font.woff2&quot; as=&quot;font&quot; type=&quot;font/woff2&quot; crossorigin&amp;gt; 제대로 사용하기 위해선 webpack에서 폰트 Preload 설정을 따로 해주는 것이 좋다. 이 때 preload-webpack-plugin 해당 플러그인을 사용한다 https://d2.naver.com/helloworld/4969726 여기에도 좋은내용이 많은것 같다" }, { "title": "2022-01-04 TIL", "url": "/posts/TIL/", "categories": "TIL", "tags": "타입스크립트", "date": "2022-01-04 00:18:00 +0900", "snippet": "타입스크립트는 런타임에서 타입체크가 불가능 하다interface Square { width: number;}interface Rectangle extends Square { height: number;}type Shape = Square | Rectangle;function calculate(shape: Shape) { if (shape instanceof Rectangle) { // Error // &#39;Rectangle&#39;은 형식만 참조하지만 여기서는 값으로 사용되고 있습니다. return shape.width * shape.height; } else { return shape.width * shape.width; }}자바스크립트에서 instanceof체크는 런타임에 일어난다. 하지만 Rectangle은 타입이기 때문에 런타임 시점에는 어떠한 역할도 할 수 없다. 타입스크립트에서 자바스크립트로 컴파일 될 때 모든 인터페이스, 타입, 타입 구문은 제거된다.그렇다면 shape타입을 명확하게 하려면 어떻게 해야 할까? height 속성이 있는지 체크 한다. 속성을 체크하는 것은 런타임때 접근 가능한 값에 가능하다 (타입체커가 shape의 타입을 Rectangle로 보정해준다) function calculate(shape: Shape) { if (&#39;height&#39; in shape) { // 여기서 shape의 타입은 Rectangle이다 return shape.width * shape.height; } else { return shape.width * shape.width; } } 런타임에 접근 가능한 타입 정보를 명시적으로 저장하는 태그 기법을 사용한다. 이 기법은 런타임때 타입 정보를 쉽게 유지할 수 있기 때문에 흔하게 사용 된다 interface Square { kind: &#39;square&#39;; width: number; } interface Rectangle { kind: &#39;rectangle&#39;; width:number; height: number; } type Shape = Square | Rectangle; function calculate(shape: Shape) { if (shape.kind === &#39;rectangle&#39;) { // 여기서 shape의 타입은 Rectangle이다 return shape.width * shape.height; } else { return shape.width * shape.width; } } 런타임때 접근할 수 없는 타입과 런타임때 접근할 수 있는 값을 둘 다 사용하는 기법이 있는데 타입을 클래스로 만드는 것이다 (인터페이스는 타입으로만 사용할 수 있지만 클래스로 선언할 경우 타입과 값 모두 사용할 수 있다) class Square { constructor(public width: number) {} } class Rectangle extends Square { constructor(public width: number, public height: number) { super(width); } } type Shape = Square | Rectangle; function calculate(shape: Shape) { if (shape instanceof Rectangle) { return shape.width * shape.height; } else { return shape.width * shape.width; } } Next js의 _app.js 과 _document.js보통 _app.js와 _document.js는 페이지에 공통으로 적용할 내용을 작성한다. 하지만 차이점이 있는데 그 차이점에 대해 알아보자 _app.js 서버로 요청이 들어왔을 때 가장 먼저 실행된다 페이지에 적용할 공통 레이아웃 역할을 한다 _document.js _app.js 다음에 실행되고 메타태그나 body태그 안에 들어갈 내용을 개발자가 커스터마이징할 때 사용한다 주로 폰트나 charset, 웹 접근성 관련 설정을 한다 import Document, { Html, Head, Main, NextScript } from &quot;next/document&quot;;export default class MyDocument extends Document { render() { return ( &amp;lt;Html&amp;gt; &amp;lt;Head&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;meta charSet=&quot;utf-8&quot;&amp;gt;&amp;lt;/meta&amp;gt; &amp;lt;body&amp;gt; &amp;lt;Main /&amp;gt; &amp;lt;NextScript /&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/Head&amp;gt; &amp;lt;/Html&amp;gt; ); }} 언제나 서버에서 실행되기 때문에 브라우저 API나 이벤트 핸들러가 있는 코드는 실행되지 않는다. 그렇기 때문에 비즈니스 로직을 여기서 추가하면 안된다. " }, { "title": "이미지 사이즈 최적화", "url": "/posts/web-optimization-image-size/", "categories": "웹 성능 최적화", "tags": "이미지 사이즈 최적화", "date": "2022-01-03 16:34:00 +0900", "snippet": "이미지 사이즈 최적화는 너무 당연한 얘기지만 간단히 말하면 이미지의 크기를 줄이고 이미지 용량을 낮추는 작업이라고 할 수 있다.이미지 포맷 PNG : 무손실 이미지 압축으로써 이미지 용량이 상대적으로 크다 JPG : 압축을 하기 때문에 PNG에 비해서 용량이 작다. 하지만 약간의 화질 저하가 있을 수 있다 (이미지 최적화를 위해 PNG보다 JPG를 사용하는 것이 권장 된다. 투명도가 필요하지 않는 이상) WEBP : 구글에서 개발한 차세대 이미지 포맷이다. 보통 PNG, JPG 대비 더 작은 크기의 이미지를 만들 수 있다 (투명도도 지원한다. 하지만 지원하지 않는 브라우저가 있다)이미지 압축그렇다면 압축을 통해 이미지 사이즈를 어떻게 줄일 수 있을까? 구글에서 만든 squoosh를 사용하면 기존에 사용하던 이미지를 압축할 수 있다.위 사진은 squoosh에서 직접 테스트를 해본 결과인데 왼쪽 영역이 원본이고 오른쪽 영역이 압축이 된 부분이다. width와 height를 줄이고 Quality는 75정도, 포맷을 WEBP로 바꿨더니 기존 용량 대비 98%나 감소했다.썸네일이나 크게 보여주지 않아도 괜찮은 이미지 같은 경우 이것을 활용하여 최적화를 할 수 있을것이다.주의사항아까 위에도 말했듯이 WEBP를 지원하지 않는 브라우저도 있다. 그렇기 때문에 브라우저에 따라 분기처리를 해야 하는데 &amp;lt;picture&amp;gt; 태그를 사용하여 이를 해결할 수 있다.&amp;lt;picture&amp;gt; &amp;lt;!-- 브라우저가 먼저 webp 확장자를 사용할 수 있는지 판단하고 사용할 수 있다면 source의 이미지를 보여준다 --&amp;gt; &amp;lt;source srcset=&quot;logo.webp&quot; type=&quot;image/webp&quot;&amp;gt; &amp;lt;!-- 만약 webp를 지원하지 않는다면 img의 이미지를 보여준다 --&amp;gt; &amp;lt;img src=&quot;logo.png&quot; alt=&quot;logo&quot;&amp;gt;&amp;lt;/picture&amp;gt;적용 모습const Card = (props) =&amp;gt; { const imageRef = useRef(null); useEffect(() =&amp;gt; { const options = {}; const callback = (entries, observer) =&amp;gt; { entries.forEach(entry =&amp;gt; { if (entry.isIntersecting) { const target = entry.target; const previousSibling = target.previousSibling; target.src = target.dataset.src; previousSibling.src = previousSibling.dataset.srcset; // 이미 감지되어서 해당 로직이 실행되었기 때문에 감지를 해제시켜준다. observer.unobserve(entry.target); } }); }; const observer = new IntersectionObserver(callback, options); observer.observe(imageRef.current); }, []); return ( &amp;lt;div&amp;gt; &amp;lt;picture&amp;gt; &amp;lt;source data-srcset={props.webp} type=&quot;image/webp&quot;&amp;gt; &amp;lt;img data-src={props.image} ref={imageRef} /&amp;gt; &amp;lt;/picture&amp;gt; &amp;lt;/div&amp;gt; );}export default Card;" }, { "title": "Intersection Observer를 활용한 이미지 lazy 로딩", "url": "/posts/web-optimization-image-lazy/", "categories": "웹 성능 최적화", "tags": "이미지 lazy 로딩", "date": "2022-01-03 13:24:00 +0900", "snippet": "Intersection Observer를 사용한 이미지 Lazy 로딩은 해당 이미지가 뷰포트에 보여졌을 때 로딩을 하는 방법이다.예를 들어 어떤 홈페이지의 메인 컨텐츠로 보여야할 동영상이 하나 있고, 그 아래쪽에는 여러 이미지들이 있는 페이지라고 가정해보자메인 컨텐츠가 동영상 이기 때문에 사용자가 가장 먼저 봐야 할 컨텐츠는 동영상이어야 한다. 하지만 아래와 같은 상황 때문에 동영상을 바로 못 볼수도 있다. (이미지를 다운로드 하고 있을 동안 동영상은 대기 중 상태이다)시간이 지나고 이미지 다운로드가 얼추 완료되면 그제서야 동영상이 다운로드 되는 것을 알 수 있다.즉, 화면에 보이지 않는 이미지 때문에 정작 사용자가 메인으로 봐야 할 컨텐츠를 제대로 못 보는 경우가 생길 수도 있다. 그렇기 때문에 이미지가 Viewport에 보일 때 다운로드 함으로써 사용자 경험을 좋게 할 수 있다.이것이 바로 이미지 Lazy 로딩 기법이다.사용 방법const Card = (props) =&amp;gt; { const imageRef = useRef(null); useEffect(() =&amp;gt; { const options = {}; const callback = (entries, observer) =&amp;gt; { entries.forEach(entry =&amp;gt; { if (entry.isIntersecting) { entry.target.src = entry.target.dataset.src; // 이미 감지되어서 해당 로직이 실행되었기 때문에 감지를 해제시켜준다. observer.unobserve(entry.target); } }); }; const observer = new IntersectionObserver(callback, options); observer.observe(imageRef.current); }, []); return ( &amp;lt;div&amp;gt; &amp;lt;!-- 이미지가 Viewport에 들어왔을 때 src를 지정해 줄것이다 --&amp;gt; &amp;lt;img data-src={props.image} ref={imageRef} /&amp;gt; &amp;lt;/div&amp;gt; );}export default Card;" }, { "title": "문제해결 패턴 - 슬라이딩 윈도우", "url": "/posts/problem-solving-pattern-sliding-window/", "categories": "알고리즘, 기본내용", "tags": "슬라이딩 윈도우", "date": "2021-12-28 18:14:00 +0900", "snippet": "슬라이딩 윈도우는 배열이나 문자열에서 데이터의 연속성 구조를 찾을 때 유용하다문제정수로된 배열과 n이 주어졌을 때 배열에서 n개의 연속된 요소들 중 최대 합을 구해라예시)maxSum([1, 2, 5, 2, 8, 1, 5], 2); // 10maxSum([], 4); // null풀이const maxSum = (arr, num) =&amp;gt; { let maxSum = 0; let tempSum = 0; if (arr.length &amp;lt; num) { return null; } for (let i = 0; i &amp;lt; num; i += 1) { maxSum += arr[i]; } tempSum = maxSum; for (let i = num; i &amp;lt; arr.length; i += 1) { tempSum = tempSum - arr[i - num] + arr[i]; maxSum = Math.max(maxSum, tempSum); } return maxSum;};말 그대로 슬라이딩 하듯이 풀리는 방법이다.예를 들어 배열이 [7, 5, 2, 9, 1, 2, 7, 10, 31]이고, num이 3일 경우 최초 7, 5, 2 요소에 대한 합(tempSum)을 구하고 그 다음에 5, 2, 9의 합을 또 바로 구하는 것이 아니라 기존에 구한 tempSum의 값에서 단지 7을 빼고 9를 더하면 되는 것이다.이런식으로 계속 해결하는 것이 바로 슬라이딩 윈도우 기법이다!" }, { "title": "문제해결 패턴 - 다중 포인터", "url": "/posts/problem-solving-pattern-multiple-pointer/", "categories": "알고리즘, 기본내용", "tags": "다중 포인터", "date": "2021-12-28 13:41:00 +0900", "snippet": "다중 포인터 패턴의 핵심은 배열이 있고, 인덱스에 맞게 2개이상의 포인터를 지정하고 조건에 따라 그 포인터의 위치를 하나씩 옮겨가며 문제를 해결하는 방법이다문제 1정수로 구성되어 있고 정렬된 배열이 주어질 때 두 수의 합이 0인 첫 번째 쌍의 정수를 구해야 한다.예시)sumZero([-3, -2, -1, 0, 1, 2, 3]) // [-3, 3]sumZero([-2, 0, 1, 3]) // undefinedsumZero([1, 2, 3]) // undefined풀이const sumZero = array =&amp;gt; { let left = 0; let right = array.length - 1; while (left &amp;lt; right) { let sum = array[left] + array[right]; if (sum === 0) { return [array[left], array[right]]; } else if (sum &amp;gt; 0) { // 두 수의 합이 0보다 크면 우측의 포인터를 감소 시킨다 right -= 1; } else { // 두 수의 합이 0보다 작으면 좌측의 포인터를 증가 시킨다 left += 1; } }};문제 2정수로 구성되어 있고 정렬된 배열이 주어질 때 해당 배열의 유니크한 값의 개수를 리턴해라예시)countUniqueValue([1, 1, 1, 1, 2]) // 2countUniqueValue([1, 1, 2, 3, 4, 4, 4, 5]) // 5countUniqueValue([]) // 0나의 풀이function countUniqueValues(arr) { if (arr.length === 0) { return; } if (arr.length === 1) { return 1; } let left = 0; let right = 1; while (right &amp;lt; arr.length) { if (arr[left] === arr[right]) { right += 1; continue; } if (arr[left] !== arr[right]) { left += 1; arr[left] = arr[right]; } } return left + 1;}더 간단한 풀이function countUniqueValues(arr) { if (arr.length === 0) return 0; let i = 0; for (let j = 1; j &amp;lt; arr.length; j += 1) { if (arr[i] !== arr[j]) { i += 1; arr[i] = arr[j]; } } return i + 1;}" }, { "title": "문제해결 패턴 - 빈도수 세기", "url": "/posts/problem-solving-pattern-freq/", "categories": "알고리즘, 기본내용", "tags": "빈도수 세기", "date": "2021-12-28 09:48:00 +0900", "snippet": "빈도수 세기 패턴은 여러개의 데이터와 입력값이 있고 이 데이터들이 비슷한 값을 갖거나 anagram인지 확인할 때, 서로 비슷한 값을 가졌는지 확인할 때 등등 데이터와 빈도를 비교할 때 사용하면 좋은 패턴이다. 이 패턴을 사용하면 O(n)의 시간 복잡도를 가질 수 있다.문제2개의 배열이 있고 두 번째 배열에는 첫 번째 배열의 각 요소에 제곱을 한 값들이 빈도수에 맞게 존재하면 true를 리턴하는 함수를 작성해야 한다. (순서는 상관 없다)예시)const array1 = [1, 1, 4, 5]const array2 = [16, 1, 25, 1]check(array1, array2) // trueconst array3 = [1, 1, 3, 4]const array4 = [9, 1, 16, 49]check(array1, array2) // false -&amp;gt; 49의 제곱근인 7이 없을 뿐 더러, 1의 개수가 맞지 않음나쁜 풀이const check = (array1, array2) =&amp;gt; { if (array1.length !== array2.length) { return false; } for (let i = 0; i &amp;lt; array1.length; i += 1) { const value = array1[i]; let correctIndex = array2.indexOf(value ** 2); if (correctIndex === -1) { return false; } array2.splice(correctIndex, 1); } return true;};이 풀이는 O(n ** 2)의 시간복잡도를 가지는데 그 이유는 for loop 안에서 indexOf, splice를 사용하기 때문이다.좋은 풀이const check = (array1, array2) =&amp;gt; { if (array1.length !== array2.length) { return false; } const counter1 = {}; const counter2 = {}; for (const value of array1) { counter1[value] = (counter1[value] || 0) + 1; } for (const value of array2) { counter2[value] = (counter2[value] || 0) + 1; } for (const key in counter1) { // 제곱인 요소가 없으면 false if (!(key ** 2 in counter2)) { return false; } // 개수가 맞지 않으면 false if (counter2[key ** 2] !== counter1[key]) { return false; } } return true;};이 풀이는 for loop의 개수는 늘어났지만 시간복잡도로 따지면 O(n)이다." }, { "title": "컴포넌트, 이미지 Preloading", "url": "/posts/web-optimization-preloading/", "categories": "웹 성능 최적화", "tags": "Preloading", "date": "2021-12-27 23:38:00 +0900", "snippet": "preloading이란 말 그대로 미리 로딩을 해놓는 것이다. 컴포넌트와 이미지에 대해 preloading을 할 수 있는데 하나씩 알아보도록 하겠다.컴포넌트 preloading가령, 아래와 같이 최적화를 위해 어떤 컴포넌트를 lazy 로딩 처리 했다고 가정해보자import { useState, Suspense, lazy } from &#39;react&#39;;const LazyModal = lazy(() =&amp;gt; import(&#39;./components/Modal&#39;));const App = () =&amp;gt; { const [showModal, setShowModal] = useState(false); return ( &amp;lt;div className=&#39;App&#39;&amp;gt; &amp;lt;Suspense fallback={null}&amp;gt; {showModal ? ( &amp;lt;LazyModal closeModal={() =&amp;gt; { setShowModal(false); }} /&amp;gt; ) : null} &amp;lt;/Suspense&amp;gt; &amp;lt;/div&amp;gt; );}export default App;이렇게 할 경우 최초 화면에 접속했을 땐 모달 관련 파일은 바로 다운로드 받지 않고 showModal 상태의 변경에 따라 모달이 보여질 때 해당 리소스를 서버로부터 받을 것이다. 최적화는 되어 있지만 만약 해당 모달 컴포넌트가 복잡하거나 용량이 크다면 사용자가 모달 오픈 버튼을 눌렀을 때는 오히려 사용자 경험이 더 안좋아 질것이다.그렇다면 어떻게 해결해야 할까?이 때 preloading을 사용하는 것이다. 지금 생각해 볼 수 있는 방법은 2가지 정도다.버튼에 마우스를 올렸을 때 로딩import { useState, Suspense, lazy } from &#39;react&#39;;const LazyImageModal = lazy(() =&amp;gt; import(&#39;./components/ImageModal&#39;));const App = () =&amp;gt; { const [showModal, setShowModal] = useState(false); const handleMouseEnter = () =&amp;gt; { import(&#39;./components/ImageModal&#39;); }; return ( &amp;lt;div className=&#39;App&#39;&amp;gt; &amp;lt;button onClick={() =&amp;gt; { setShowModal(true); }} onMouseEnter={handleMouseEnter} &amp;gt; 모달 오픈 &amp;lt;/button&amp;gt; &amp;lt;Suspense fallback={null}&amp;gt; {showModal ? ( &amp;lt;LazyImageModal closeModal={() =&amp;gt; { setShowModal(false); }} /&amp;gt; ) : null} &amp;lt;/Suspense&amp;gt; &amp;lt;/div&amp;gt; );}export default App;컴포넌트가 마운트 되었을 때 로딩import { useState, Suspense, lazy, useEffect } from &#39;react&#39;;const LazyImageModal = lazy(() =&amp;gt; import(&#39;./components/ImageModal&#39;));const App = () =&amp;gt; { const [showModal, setShowModal] = useState(false); useEffect(() =&amp;gt; { import(&#39;./components/ImageModal&#39;); }, []); return ( &amp;lt;div className=&#39;App&#39;&amp;gt; &amp;lt;button onClick={() =&amp;gt; { setShowModal(true); }} onMouseEnter={handleMouseEnter} &amp;gt; 모달 오픈 &amp;lt;/button&amp;gt; &amp;lt;Suspense fallback={null}&amp;gt; {showModal ? ( &amp;lt;LazyImageModal closeModal={() =&amp;gt; { setShowModal(false); }} /&amp;gt; ) : null} &amp;lt;/Suspense&amp;gt; &amp;lt;/div&amp;gt; );}export default App;이렇게 했을 경우 주요 파일들이 모두 로드되고 난 이후 모달 관련된 1.chunk.js, 2.chunk.js가 차례대로 로딩 되는 것을 알 수 있다.지금은 하나의 컴포넌트만 preloading 하니까 괜찮지만 나중엔 더 많은 컴포넌트들을 preloading 시켜야할 때가 올것이다. 이 때 매번 import를 하면 불편하므로 별도의 함수를 만들어서 더 쉽게 관리해보자!import { useState, Suspense, lazy, useEffect } from &#39;react&#39;;const lazyWithPreload = importFunction =&amp;gt; { const Component = lazy(importFunction); Component.preload = importFunction; return Component;};const LazyImageModal = lazyWithPreload(() =&amp;gt; import(&#39;./components/ImageModal&#39;));const App = () =&amp;gt; { const [showModal, setShowModal] = useState(false); useEffect(() =&amp;gt; { LazyImageModal.preload(); }, []); return ( &amp;lt;div className=&#39;App&#39;&amp;gt; &amp;lt;button onClick={() =&amp;gt; { setShowModal(true); }} &amp;gt; 모달 오픈 &amp;lt;/button&amp;gt; &amp;lt;Suspense fallback={null}&amp;gt; {showModal ? ( &amp;lt;LazyImageModal closeModal={() =&amp;gt; { setShowModal(false); }} /&amp;gt; ) : null} &amp;lt;/Suspense&amp;gt; &amp;lt;/div&amp;gt; );};export default App;이미지 preloading이미지는 기본적으로 화면에 보여지는 시점이 아니면 로드가 되지 않는다. 그렇다면 어떻게 preloading을 할 수 있을까? 바로 자바스크립트의 Image객체를 사용하는 것이다.const image = new Image();image.src = &#39;이미지의 주소&#39;;이렇게 image.src에 값을 지정해주는 순간 Network 탭을 보면 이미지를 불러오는 것을 알 수 있다. 한 가지 주의해야할 점은 컴포넌트와 다르게 이미지는 image.src로 같은 이미지를 불러와도 네트워크 요청은 또 보낸다는 것이다. (내가 배운 내용에서는 이렇게 설명했지만 실제로 테스트를 해보니 여러번 호출하여도 한 번만 불러왔다. 일단 더 찾아보고 이에 대한 설명도 작성해보겠다.)" }, { "title": "애니메이션 최적화", "url": "/posts/web-optimization-animation/", "categories": "웹 성능 최적화", "tags": "애니메이션 최적화", "date": "2021-12-27 21:22:00 +0900", "snippet": "애니메이션을 최적화 하기 위해선 브라우저의 렌더링 과정에 대해 알고있어야 한다.브라우저 렌더링 과정 필요한 html, js, css 파일등을 서버로부터 다운로드 받는다 DOM 트리 + CSSOM 트리 생성 렌더트리생성 렌더트리에는 페이지를 렌더링 하는데 필요한 노드만 포함된다. DOM 트리와 CSSOM 트리가 생성되면 이 둘을 합쳐 렌더트리를 만든다 레이아웃 레이아웃 단계는 뷰포트 내에서 각 요소의 크기와 위치를 계산한다 페인팅 렌더트리의 각 노드를 화면의 실제 픽셀로 변환한다 Reflow &amp;amp; Repaint사용자가 웹 페이지에 처음 접속하면 렌더링 과정을 거치게 되고 화면에 요소가 그려진다. 그 이후 사용자가 여러 액션들을 하며 발생하는 이벤트로 인해 어떤 새로운 HTML 요소가 생성, 삭제, 변경될 수 있다.이런 변경이 생겨 영향을 받게되는 모든 노드는 렌더트리 생성과 레이아웃 과정을 다시 수행하는데 이 과정을 리플로우(Reflow)라고 한다.리플로우는 단지 변경사항을 반영하기 위해 렌더링 트리를 생성하고 레이아웃 과정을 다시 하는 것이고 변경된 내용이 화면에 그려지기 위해서는 리페인트(Repaint)단계를 거쳐야 한다.위의 내용을 바탕으로 유추해봤을 때 리플로우가 일어나야 리페인트가 일어나는 구나라고 추측할 수 있지만 무조건 그러는 것은 아니다.레이아웃에 영향이 미치지 않는 속성이 변경됐을 땐 리플로우 없이 바로 리페인트만 일어난다.하지만 리플로우가 발생한다면 리페인트도 반드시 발생한다리플로우가 일어나는 속성들 position width, height margin, padding border, border-width font-size, font-weight overflow 등등리페인트가 일어나는 속성들 background, color text-decoration border-style, border-radius 등등애니메이션 최적화의 핵심비용이 많이드는 레이아웃과, 리페인트 단계를 건너 뛰는 것이다 width나 height같은 요소의 크기가 변경되었을 경우 리플로우가 발생하기 때문에 브라우저 렌더링 과정을 또 모두 진행한다 color나 background-color 이 변경되었을 경우 브라우저 렌더링 과정이 진행되지만 그 중 레이아웃 단계는 생략되고 렌더트리생성 이후 바로 리페인트 단계로 넘어간다. 그 이유는 크기가 변경된 것이 아니기 때문에 레이아웃 단계를 진행할 필요가 없고 단지 색상이 변경되었기 때문이다.그렇다면 레이아웃 단계와 리페인트 단계 모두 생략할 수는 없을까? 그 방법은 GPU의 도움을 받으면 가능하다.transform이나 opacity 같은 GPU가 관여할 수 있는 속성을 변경하는 것이다" }, { "title": "문제해결 접근법", "url": "/posts/problem-solving-approach/", "categories": "알고리즘, 기본내용", "tags": "문제해결", "date": "2021-12-27 17:14:00 +0900", "snippet": "문제를 풀기 전에, 코드를 적어내려 가거나 칠판에 적기 전에, 즉 무엇을 하던지 간에 먼저 한 발짝 뒤로 가서 내가 해야 하는 일이 무엇인지 이해하는 것이 제일 중요하다.그냥 달려들었을 때 함정에 빠지거나 혼란에 빠질수도 있기 때문이다.내가 특히 이런 방식으로 문제에 접근을 많이 했던것 같다. 일단 시작하고, 코드를 써내려 가다보면 해결책을 알게 되겠지라는 정말 위험한 생각을 가지고 있었는데 이렇게 문제에 접근할 때 풀린 경우도 있었지만 내가 생각했던 데로 흐르지 않으면 당황하고 혼란에 빠졌던 경험이 많았다 이미 한가지 접근법으로만 몰두했기 때문에 하나씩 지우면서 하다보면 결국 전체 코드를 다 지우고 새로 작성한것 같다. 이것만으로 벌써 시간을 많이 날리게 된 것이다.문제해결 접근법 문제를 이해하자 (문제를 나만의 표현으로 바꿔서 정확히 이해하자) 문제에 입력하는 값은 무엇인가? 출력값은 어떤가? (정수인가 스트링인가 등등) 출력값이 입력값에 의해 결정될 수 있나? 출력값이 무엇이 되어야 하나? 문제를 이해했으면 구체적인 예시를 탐색하자 간단한 예시부터 시작해서 복잡한 예시를 탐색하자 경계조건은 비어있는 입력값부터 시작하자 (유효하지 않은 값을 입력하면 어떻게 될까? 라는 생각은 항상 가지자!) 대소문자 구분 등등 문제를 쪼개자 문제를 해결하기 위한 실제 단계들을 따라가면서 적어보자 완벽한 문법대로 적을 필요도 없고 가이드 역할을 할 수 있는 정도로 적어보자 모든것이 엄청나게 자세할 필요도 없다 해결 방법의 가장 기본적인 구성요소들을 적기만 하면 된다 이렇게 문제를 쪼개서 적는다면 실제 코드를 작성하기 전에 작성해야 할 코드에 대해서만 생각할 수 있고 마음 내키는 대로 하거나 떠오르는 대로 하는것이 아니라 어렵거나 이해가 잘 되지 않는 부분을 제대로 알아내는데 도움이 된다 이렇게 하고 문제에 직접 달려들자 문제 풀기 이게 마지막 단계는 아니다 내가 모르는 것이 있거나 어려운 부분이 있다면 문제를 간단히 만들기를 해야 한다. 만약 이 문제를 내가 구글링 없이 절대 풀지못할 것 같다? 그럼 일단 넘어가고 내가 풀 수 있는 부분을 먼저 보고 해결되면 다시 돌아오자 뒤돌아보기, 리팩토링 코드 퀄리티가 어찌됐든 문제를 풀었거나 조금 간단하게 만들었을 것이다 그렇다면 뒤돌아서 확인 하고 리팩토링을 해야한다 만약 정상적으로 잘 동작했다고 바로 끝내버리는 경우가 있는데 그래도 이왕 내가 짠 코드 개선해보면 손해볼것은 없다 하지 않는다면 좋은 기회를 날리는 것! 그리고 효율성과 가독성이라는 두 요소 사이에는 적절한 균형이 필요하다 다른 접근법이 있는지, 빼먹은 것은 없는지 면접에서 물어볼 수도 있다 결론 가장 중요한 것은 문제를 이해하는 것이다 코딩테스트 뿐만 아니라 그냥 일을 할때나 토이프로젝트를 진행할 때도 문제를 제대로 이해하고 있어야 제대로 된 해결방안을 알 수 있다. 문제를 바로 풀기 어렵다면 더 간단하더라도 할 수 있는 방법으로 접근해보자 해결하고 나중에 통합하면 된다 가장 중요한 것은 다 풀고나서 코드를 되돌아보고 교훈을 얻거나 수정하는 것이다 문제를 이해하고 예시를 탐색하는 첫 두가지에서 시작하자" }, { "title": "코드 스플리팅", "url": "/posts/web-code-splitting/", "categories": "웹 성능 최적화", "tags": "웹 성능 최적화, 코드 스플리팅", "date": "2021-12-26 20:00:00 +0900", "snippet": "코드 스플리팅 Code Splitting이란 말 그대로 코드를 분할하여 큰 번들파일을 쪼개서 작은 사이즈의 파일로 만드는 것이다. 그렇다면 코드를 왜 분할하는 것일까?위의 사진은 cra-bundle-analyzer을 사용한 번들 분석 결과이다. webpack-bundle-analyzer도 있지만 지금은 CRA로 만든 프로젝트를 분석해본 것이기 때문에 cra-bundle-analyzer를 사용했다. 물론 eject를 하거나 craco 같은 별도의 라이브러리를 통해 webpack-bundle-analyzer를 사용해도 된다.분석 결과를 보면 refractor라는 것이 번들의 절반을 차지하고 있다. 그럼 이것이 무엇인지 확인하려면 package-lock.json을 한 번 살펴보자!확인해 보니 코드 문법을 하이라이팅 시키는 react-syntax-highlighter라이브러리에 필요한 라이브러리로써 사용되고 있었다.&quot;react-syntax-highlighter&quot;: { &quot;version&quot;: &quot;12.2.1&quot;, &quot;resolved&quot;: &quot;생략&quot;, &quot;integrity&quot;: &quot;생략&quot;, &quot;requires&quot;: { &quot;@babel/runtime&quot;: &quot;^7.3.1&quot;, &quot;highlight.js&quot;: &quot;~9.15.1&quot;, &quot;lowlight&quot;: &quot;1.12.1&quot;, &quot;prismjs&quot;: &quot;^1.8.4&quot;, // 여기서 사용 됨 &quot;refractor&quot;: &quot;^2.4.1&quot; }},이것을 확인했다고 해서 최적화를 어떻게 진행할 수 있을까? 먼저 이 라이브러리가 어디에서 쓰이는 지 확인해 봐야 할것이다. 현재 이 라이브러리는 게시글의 상세화면에서만 사용하고 있다.즉, 게시물 전체를 보여주는 화면에서는 굳이 로딩될 필요가 없는 것이다! 이 때 바로 Code Splitting을 사용하여 불필요한 리소스를 줄이고 페이지의 로딩속도를 향상시킬 수 있다.Code Splitting의 패턴코드 스플리팅은 몇 가지의 패턴을 가지고 있다. 페이지 별로 코드를 분할 모듈 별로 코드를 분할 (여러 페이지에서 같은 모듈을 사용할 경우) 위의 두 가지 방법을 적절히 섞은 방법코드 스플리팅의 가장 핵심은 불필요한 코드, 중복된 코드 없이 적절한 사이즈의 코드가 적절한 타이밍에 로드되도록 하는 것이다.Code Splitting 방법자세한 내용은 React 공식 홈페이지에서 확인할 수 있다.가장 간단하게는 React Router라이브러리를 사용해서 라우트 기반의 코드 스플리팅을 하는 것이다.import React, { Suspense, lazy } from &#39;react&#39;;import { BrowserRouter as Router, Route, Switch } from &#39;react-router-dom&#39;;const Home = lazy(() =&amp;gt; import(&#39;./routes/Home&#39;));const About = lazy(() =&amp;gt; import(&#39;./routes/About&#39;));const App = () =&amp;gt; ( &amp;lt;Router&amp;gt; &amp;lt;Suspense fallback={&amp;lt;div&amp;gt;Loading...&amp;lt;/div&amp;gt;}&amp;gt; &amp;lt;Switch&amp;gt; &amp;lt;Route exact path=&quot;/&quot; component={Home}/&amp;gt; &amp;lt;Route path=&quot;/about&quot; component={About}/&amp;gt; &amp;lt;/Switch&amp;gt; &amp;lt;/Suspense&amp;gt; &amp;lt;/Router&amp;gt;);하지만 이렇게 한다고 해서 바로 사용할 수 있는 것이 아니다! 😱 코드 스플리팅을 하는 주체는 리액트가 아니라 웹팩이기 때문에 웹팩에서 별도의 설정을 해줘야 한다! CRA로 프로젝트를 구성했을 경우 별도의 설정을 할 필요는 없다!웹팩 공식사이트위 코드와 같이 코드 스플리팅을 했을 경우 번들 분석결과는 아래와 같다.처음과 다르게 react-dom 부분이 별도로 분리된 모습을 볼 수 있다!Lighthouse 결과오우 🚀 중간에 진행했던 몇몇의 최적화와 코드 스플리팅을 하는 것 만으로도 51점에서 96점이 되었다!!하지만 이것은 production 모드에서 측정을 한 것이 아니라 development 모드에서 진행한 것이다. 성능 측정은 production 모드에서 측정을 해야한다. 그 이유는 웹팩 설정에 따라 production 모드에서는 코드를 minify 하거나 uglify 하기 때문에 development와 성능차이가 있을 수 있기 때문이다텍스트 압축서버에서 보내는 리소스를 압축해서 서비스를 하는 것이다! 이렇게 하면 다운로드 하는 리소스의 크기가 줄어들어 더 빠르게 컨텐츠를 로드할 수 있다.네트워크 탭에서 현재 요청하고 있는 API의 응답 헤더를 살펴보면 Content-Encoding에 gzip이라고 되어 있는 부분이 있다 이 의미는 gzip이라는 인코딩 방식을 통해 압축되어 있다는 의미이다.이와 반대로 빌드된 main.js를 보면 응답 헤더에서는 Content-Encoding를 찾아볼 수 없다. 이 의미는 번들링된 파일은 압축되어 있지 않다는 의미이다. 웹상에서 사용하는 압축 알고리즘에는 보통 gzip과 Deflate이 있다. gzip이 Deflate보다 높은 압축률을 가지고 있다.그리고, 압축여부를 확인할 때 응답 헤더에서 확인되는 것으로 유추했을 때 클라이언트에서 하는게 아니라 번들 파일을 서비스 해주는 서버에서 해줘야 한다. 유의해야 할 점 서버에서 압축 설정이 되어 있는데 네트워크 탭을 보면 어떤 파일은 gzip으로 압축이 잘 되어 있고, 어떤 파일은 압축이 되어있지 않는 경우도 있을 것이다. 그 이유는 서버에서 압축을 하면 클라이언트에서는 압축을 해제해야 하는데 무분별하게 모든 파일을 압축해버리면 오히려 시간이 더 걸릴 수도 있기 때문이다. 보통 2kb를 기준으로 압축 유무를 결정한다.느낀점텍스트 압축은 정말 가성비 좋은 최적화 방법인것 같다. 물론 서버에서도 설정해야 하지만" }, { "title": "Opportunities", "url": "/posts/web-optimization-Opportunities/", "categories": "웹 성능 최적화", "tags": "웹 성능 최적화, Opportunities", "date": "2021-12-26 19:00:00 +0900", "snippet": "지난 글에 이어서 Opportunities 항목을 하나씩 최적화 해보자!내가 확인하고 있는 코드의 Opportunities 결과는 다음과 같다.그럼, 하나하나 살펴보면서 최적화를 진행해 보자!Properly size imagesProperly size images 항목은 셀룰러 데이터를 절약하고 로드 시간을 단축하기 위해 적절한 사이즈의 이미지를 제공해야 한다는 것을 알려준다. 우측 화살표를 눌러보면 자세한 내용을 볼 수 있다.우측에 Potential Savings는 해당 이미지를 이정도 까지 save 할 수 있다는 것을 의미한다.개발자도구의 inspect로 해당 이미지를 보면화면에 렌더링 된 사이즈는 120 x 120지만 실제 이미지 원본의 사이즈는 1200 x 1200라는 것을 알 수 있다. 그럼 이럴 때 어떤 사이즈를 불러와서 화면에 렌더링 시켜야 할까? 120 x 120의 사이즈로 불러와 렌더링 하는 것도 맞지만 맥이나 레티나 디스플레이를 사용하는 경우 더 많은 픽셀을 그릴 수 있으므로 240 x 240로 렌더링 하는 것이 좋다.그럼 이미지 용량을 어떻게 줄일 수 있을까? 만약 프로젝트에서 assets로 관리하는 파일이라면 직접 압축을 하거나 이미지의 물리적인 크기를 줄여서 용량을 줄일 수 있을 것이다. 하지만 API를 통해 받아오는 이미지 같은 경우는 어떻게 해야할까? 바로 Image CDN을 사용하는 것이다.개발을 하다가 image.com?src=[image src]&amp;amp;width=240&amp;amp;height=240 이러한 형태로 개발자가 원하는 사이즈로 가공하여 받을 수 있다.Minify JavaScriptMinify JavaScript는 자바스크립트 코드를 minify하라는 의미이다. minify란 자바스크립트 코드에서 공백이나 줄바꿈 등을 줄이는 것인데 리액트 코드를 CRA로 생성했거나 별도로 웹팩 설정을 하고 production 모드로 빌드를 할 때 minify할 수 있다!" }, { "title": "웹 성능 최적화 시작", "url": "/posts/web-optimization-start/", "categories": "웹 성능 최적화", "tags": "웹 성능 최적화", "date": "2021-12-26 17:00:00 +0900", "snippet": "시작더 효율적인 프론트엔드 개발자가 되고싶어 웹 성능 최적화에 대해 학습하려 한다. 아직 익숙하지 않아 바로바로 적용하는 데에 어려울 수도 있지만 계속 하면서 습관화 할 수 있도록 해야겠다! 🔥🔥🔥lighthouse가장 쉽게 성능을 확인할 수 있는 방법은 크롬 개발자 도구의 lighthouse이다.자신이 원하는 설정을 체크하고 보고서 생성버튼을 누르기만 하면 아래와 같이 점수, 각 항목에 대한 설명과 최적화 가이드를 해준다.우리가 개발한 프로젝트들의 해당 점수를 하나하나 높혀가면 된다!해당 보고서 결과를 밑으로 조금 내려보면 Opportunities 항목과 Diagnostics이 보이는데 이것은 다음과 같다. Opportunities: 리소스의 관점에서 가이드를 제시해 준다. 즉 로딩성능 최적화와 연관이 있는 항목들을 보여준다. Diagnostics: 페이지의 실행 관점에서 가이드를 제시해 준다. 즉, 렌더링 관점에서 연관이 있는 항목들을 보여준다.그럼 다음 글에서 Opportunities와 Diagnostics에 대해 살펴보도록 하겠다." }, { "title": "첫 글", "url": "/posts/Intro/", "categories": "Intro", "tags": "", "date": "2021-12-22 00:00:00 +0900", "snippet": "기존 티스토리 블로그에 있던 글도 시간이 날 때 마다 하나씩 옮겨야 겠다. 😁" } ]
